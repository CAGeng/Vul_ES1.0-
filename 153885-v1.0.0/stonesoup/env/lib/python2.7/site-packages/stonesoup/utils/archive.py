import os
import os.path
import re
import time
import subprocess

# Enum support - PEP 435
try :
    from enum import Enum  #python 3.4+
except ImportError :
    from flufl.enum import Enum #python 2.7-3.3

# 3rd party modules
import magic

# hide some of the internal stuff in the event someone actually uses *
__all__ = [ 'ArchiveType', 
            'CompressionType', 
            'archive_format_and_compression',
            'archive_is_tar',
            'archive_info',
            'archive_extract',
            'archive_create_tar' ]


class ArchiveType(Enum) :
    unsupported = 1
    none = 2
    tar = 3


class CompressionType(Enum) :
    unsupported = 1
    none = 2
    gzip = 3
    bzip2 = 4
    xz = 5
    zip = 6


# This is a regex that will parse the structure mime-type and mime-encoding string
# returned from filemagic (i.e. libmagic) into groups of the important information.
# The main thing we want here is the mime type and any compressed encoding mime type.
# Usage:
#     match = _MIME_TYPE_PATTERN.match('application/x-tar; charset=binary compressed-encoding=application/x-zip; ...')
#     # This should always exist for simple type (e.g. text, html, xml, tar) and compressed archives
#     mime_type = match.group('mime_type')
#     # This will only exist im compressed
#     compressed_mime_type = match.group('mime_type_compressed_encoding')
#
# Note: A simple zip will come back as:
#           mime_type = 'application/x-empty'
#           mime_type_compressed_encoding = 'application/zip'
_MIME_TYPE_PATTERN = re.compile('^(?P<mime_type>[-+\w]+/[-+\w]+)(; charset=(?P<mime_type_charset>[-\w]+))?( compressed-encoding=(?P<mime_type_compressed_encoding>[-+\w]+/[-+\w]+)(; charset=[-\w]+){1,2})?$')


# Archive types
_ARCHIVE_MIME_TYPES = { 'application/x-tar': ArchiveType.tar,
                        'application/x-empty': ArchiveType.none }


# Compression types
_COMPRESSION_MIME_TYPES = { 'application/x-gzip': CompressionType.gzip,
                            'application/gzip': CompressionType.gzip,
                            'application/zip': CompressionType.zip,
                            'application/x-bzip2': CompressionType.bzip2, 
                            'application/x-xz': CompressionType.xz }


def archive_format_and_compression(archive, raise_on_unsupported=True) :
    # instruct filemagic to give us mime_type, mime_encoding, and to peek in compressed files
    magic_flags = magic.MAGIC_MIME | magic.MAGIC_MIME_ENCODING | magic.MAGIC_COMPRESS
    
    mime_type_raw = None
    
    # validate the raw argument, then get the absolute path if valid
    if archive is None or\
            len(archive) == 0 :
        raise ValueError('Archive does not exist.')
    path_absolute = os.path.abspath(archive)
    
    if not os.path.isfile(path_absolute) :
        raise ValueError('Archive does not exist.')
    
    # magic should be used in this manner to release
    # memory allocated by libmagic.so back to the OS
    with magic.Magic(flags=magic_flags) as m :
        mime_type_raw = m.id_filename(path_absolute)
    
    match = _MIME_TYPE_PATTERN.match(mime_type_raw)
    
    if match is None :
        raise RuntimeError('Failed to parse mime type and encoding.')
    
    # grab the mime type strings
    # compression_mime_type may be None is not compressed
    mime_type = match.group('mime_type')
    compression_mime_type = match.group('mime_type_compressed_encoding')
    
    #default enumerations
    archive_type = None
    compression_type = CompressionType.none
    
    try :
        archive_type = _ARCHIVE_MIME_TYPES[mime_type]
    except KeyError :
        if raise_on_unsupported :
            raise RuntimeError('Unsupported archive format \'{0}\'.'.format(mime_type))
        else :
            archive_type = ArchiveType.unsupported
    
    if compression_mime_type is not None :
        try :
            compression_type = _COMPRESSION_MIME_TYPES[compression_mime_type]
        except KeyError :
            if raise_on_unsupported :
                raise RuntimeError('Unsupported archive compression \'{0}\'.'.format(compression_mime_type))
            else :
                compression_type = CompressionType.unsupported
    
    # REMOVED CODE BRANCH - ZIP FILES
    # remove support for zip files - who would use this anyways? :P
    #if archive_type is None and\
    #        compression_type == CompressionType.zip :
    #    # this is a special case for ZIPs, as they are compressed but the inner type 
    #    # comes back as "x-empty"
    #    return ArchiveType.zip, CompressionType.none
    if archive_type == ArchiveType.none :
        # this is now broken because we got an empty inner type
        # this will typically occur when we have a compressed directory or file
        # rather than a tarball
        if raise_on_unsupported :
            raise RuntimeError('Unsupported archive type or compression.')
    
    return archive_type, compression_type

def archive_is_tar(archive) :
    return archive_format_and_compression(archive, raise_on_unsupported=False)[0] == ArchiveType.tar
    
def archive_info(archive) :
    path_absolute, filename = None, None
    
    # validate the raw argument, then get the absolute path if valid
    if archive is None or\
            len(archive) == 0 :
        raise ValueError('Archive does not exist.')
    path_absolute = os.path.abspath(archive)
    
    if not os.path.isfile(path_absolute) :
        raise ValueError('Archive does not exist.')
    
    # try to get the filename portion of the path, or fail
    filename = os.path.split(path_absolute)[1]
    if filename is None or\
            len(filename) == 0 :
        raise ValueError('Archive does not exist.')
    
    # detect the archive type and compression, if any
    archive_type, compression_type =\
        archive_format_and_compression(path_absolute)

    archive_str = '{0}: {1} archive'.format(filename, archive_type.name)
    
    if compression_type != CompressionType.none :
        archive_str = '{0} ({1} compressed)'.format(archive_str, compression_type.name)
    
    return archive_str

def archive_extract(archive, destination, *args, **kwargs) :
    path_absolute, filename = None, None
    
    # validate the raw argument, then get the absolute path if valid
    if archive is None or\
            len(archive) == 0 :
        raise ValueError('Archive does not exist.')
    path_absolute = os.path.abspath(archive)
    
    if not os.path.isfile(path_absolute) :
        raise ValueError('Archive does not exist.')
    
    # detect the archive type and compression, if any
    archive_type, compression_type =\
        archive_format_and_compression(path_absolute)
    
    extract_command = None
    
    # build the extract command for the underlying archive type.  any 
    # required decompression will be executed as a different subprocess
    # prior and piped to stdin for this command.
    if archive_type == ArchiveType.tar :
        extract_command = [ 'tar',
                            '-xvf',
                            path_absolute,
                            '-C',
                            os.path.abspath(destination) ]
        
        # check to see if we need to decompress, then extract the archive
        if compression_type != CompressionType.none :
            if compression_type == CompressionType.gzip or\
                    compression_type == CompressionType.zip :
                extract_command.append('-z')
            elif compression_type == CompressionType.bzip2 :
                extract_command.append('-j')
            elif compression_type == CompressionType.xz :
                extract_command.append('--use-compress-program')
                extract_command.append('unxz')
            else :
                raise NotImplementedError('Compression format not implemented.')
        
        # grab supported options
        arg_strip_components = kwargs.pop('strip_components', None)
        arg_strip_components = kwargs.pop('stripcomponents', arg_strip_components)
        arg_strip_components = kwargs.pop('strip-components', arg_strip_components)
        if arg_strip_components is not None :
            extract_command.extend(['--strip-components', '{0}'.format(arg_strip_components)])
        
        if len(args) != 0 :
            # apply the requested patterns to extract
            extract_command.extend(args)
    else :
        raise NotImplementedError('Archive format not implemented.')
    
    # execute the subprocesses
    extract_proc = subprocess.Popen(extract_command,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    # wait for subprocesses to execute
    extract_stdout, extract_stderr = extract_proc.communicate()
    
    # there is an issue with the OS not flushing things to disk immediately
    # they get cached and it may break immediate access to files/directories
    time.sleep(1)
    
    if extract_proc.returncode != 0 :
        raise RuntimeError('Failed to unpack archive: {0}\nError: {1}'.format(path_absolute, extract_stderr))
    
def archive_create_tar(source, destination, compression=CompressionType.gzip, *args) :
    
    # sanity checks
    if compression is None :
        compression = CompressionType.none
    elif compression == CompressionType.unsupported :
        raise ValueError('Invalid or unsupported compression.')
        
    if source is None or source == '' :
        raise ValueError('Invalid source directory or file.')
    
    # resolve root and source
    root_absolute = None
    patterns = [ ]
    
    if args is None or len(args) == 0 :
        # if no patterns are provided, we assume it to be one directory up from 
        # source path.  This is because we will by default follow the normal 
        # convention of a tar containing a single directory, under which will 
        # be all of the contents.
        root_absolute, tail = os.path.split(os.path.abspath(source))
        if tail is None or tail == '' :
            root_absolute, tail = os.path.split(root_absolute)
        patterns.append(tail)
    else :
        # when patterns are provided, they cannot be an absolute path and 
        # the directory or file referenced by source + pattern[n] must exist.
        root_absolute = os.path.abspath(source)
        
        for pattern in args :
            if os.path.isabs(pattern) :
                raise ValueError('Absolute pattern path not permitted.')
            
            if not os.path.exists(os.path.join(root_absolute, pattern)) :
                raise ValueError('Directory or file does not exist.')
        
        patterns.extend(args)
    
    # destination should be a file reference.  The enclosing path must exist.
    # also if the path exists, then it must be a file.
    destination_absolute = os.path.abspath(destination)
    destination_absolute_dirname = os.path.dirname(destination_absolute)
    
    if os.path.exists(destination_absolute) and\
            not os.path.isfile(destination_absolute) :
        raise ValueError('Destination is an existing directory.  Destination must be a reference to a file (existing or non-existing).')
    
    # ensure we have a directory to write to
    if not os.path.exists(destination_absolute_dirname) :
        raise ValueError('Destination directory does not exist: {0}'.format(destination_absolute_dirname))
        #os.makedirs(destination_absolute_dirname)
    
    # Now that we have valid arguments, we can start to execute the tar operation
    # setup the command arguments by creating the base command arguments
    archive_command = [ 'tar',
                        '-cvpf',
                        destination_absolute,
                        '-C',
                        root_absolute ]
    
    # add compression arguments if required
    if compression != CompressionType.none :
        if compression == CompressionType.gzip or\
                compression == CompressionType.zip :
            archive_command.append('-z')
        elif compression == CompressionType.bzip2 :
            archive_command.append('-j')
        elif compression == CompressionType.xz :
            archive_command.append('--use-compress-program')
            archive_command.append('xz')
        else :
            raise NotImplementedError('Compression format not implemented.')

    #patterns go on the end of the command
    archive_command.extend(patterns)

    # execute the subprocesses
    archive_proc = subprocess.Popen(archive_command,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    # wait for subprocesses to execute
    archive_stdout, archive_stderr = archive_proc.communicate()        
    
    # there is an issue with the OS not flushing things to disk immediately
    # they get cached and it may break immediate access to files/directories
    time.sleep(1)
    
    if archive_proc.returncode != 0:
        raise RuntimeError('Failed to create archive: {0}\nError: {1}'.format(destination_absolute, archive_stderr))
    