#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

import ConfigParser
import sys
import os
import StringIO
import collections

class ConfigMergeError(Exception):
    pass


class ConfigMerger(object):
    
    def __init__(self):
        self._merge_config = ConfigParser.RawConfigParser()
        self._merge_config.optionxform = str
        self._verify_config = ConfigParser.RawConfigParser()
        self._verify_config.optionxform = str
        self._bold = "\033[1m"
        self._reset = "\033[0;0m"
        self._red = "\033[31;1m"
        self._magenta = "\033[35;1m"
        
    
    def merge_configs(self, merge=None, source=None, dest=None):
        """Merge two config files together and place them
        Into the destination. 
        
        Args:
            merge: The config file we are merging with our source config
            source: A config file to verify all required attributes are in the
            merge file.
            dest: the destnation of the file. Default is None.
                - Can be either a buffer or file name to write changes to
                - If None, writes the changes to the original merge file.
                
        Returns:
            None
        """
        
        self._merger = StringIO.StringIO(); 
            
        if merge is None:
            raise ConfigMergeError("Merge config file must exist")
        elif source is None:
            raise ConfigMergeError("Source config file must exist")
        
        try:
            self._merge_config.read(merge)
            self._verify_config.read(source)
        except Exception:
            raise ConfigMergeError("Error reading the config file")
        
        #We have to ensure that the default config section
        #is copied over. ConfigParser handles the default in a weird way
        #so we hard code default in.
        print("\t{0}[{1}]{2}".format(self._magenta,"DEFAULT",self._reset)) 
        self._merger.write("[DEFAULT]\n")  
        for key, value in self._verify_config.defaults().iteritems():
            if key in self._merge_config.defaults():
                if self._merge_config.get('DEFAULT',key) == \
                self._verify_config.get('DEFAULT', key):
                    print("\t{0}={1}".format(key, value))
                else:
                    print("\t{0}{1}={2} (Non-Default){3}".format(self._red, key, 
                                                         self._merge_config.get('DEFAULT',
                                                                                 key),
                                                         self._reset))
                
            else:
                self._merge_config.set('DEFAULT',key,value)
                print("\t{0}{1}={2}{3}".format(self._bold,key, value, self._reset))
            
        for key in sorted(self._merge_config.defaults()):
            value = self._merge_config.get('DEFAULT', key)
            self._merge_config.set('DEFAULT', key, value)
            self._merger.write('{0}={1}\n'.format(key, value))  
               
        for section in self._verify_config.sections():
            print("\n")
            
            if False == self._merge_config.has_section(section):
                print("\t{0}[{1}]{2}".format(self._magenta,section, self._reset))
                self._merge_config.add_section(section)
            else:
                print("\t{0}[{1}]{2}".format(self._magenta,section, self._reset))    
            
            
            #get all default keys for the section.
            items = self.get_section(section, self._verify_config) 
            
            for key in sorted(items):
                value = self._verify_config.get(section, key)
                if False == self._merge_config.has_option(section, key):
                    
                    print("\t{0}{1}={2}{3}".format(self._bold,key, value,
                                                  self._reset))
                    self._merge_config.set(section, key, value) 
                elif self._merge_config.get(section, key) == \
                value:
                    print("\t{0}={1}".format(key, value))
                else:
                    print("\t{0}{1}={2} (Non-Default){3}".format(self._red, key, 
                                                         self._merge_config.get(section, 
                                                                                key),
                                                         self._reset))
            #Make sure it actually prints non-default sections from the merge    
            merge_items = self.get_section(section, self._merge_config)
            for key in merge_items.keys():
                if key not in items.keys():
                    print("\t{0}{1}={2} (Non-Default){3}".format(self._red, key, 
                                                         self._merge_config.get(section, 
                                                                                key),
                                                         self._reset))    
                     
        #Write out the whole merged config to our merger memory IO.
        #This is to make sure we have ALL attributes included.
        for section in self._merge_config.sections():
            self._merger.write("\n")
            self._merger.write("[{}]\n".format(section))
            merge_items = self.get_section(section, self._merge_config)
            for key in sorted(merge_items):
                self._merger.write("{}={}\n".format(key, self._merge_config.get(section,
                                                                                key)))
        try:
            if dest is None:
                open(merge, 'w').write(self._merger.getvalue())
            elif isinstance(dest, basestring):
                open(dest, 'w').write(self._merger.getvalue())
            else:
                dest.write(self._merger.getvalue())
                
        except:
                raise ConfigMergeError("Unable to open merge file to read/write.")
        
        #Flush StringIO
        self._merger.close()    
    
    def get_section(self, section, config=None):
        """Gets all non-default values """
        if config is None:
            raise ConfigMergeError("Cannot get section of empty config.")
        
        dict = {k:v for k,v in config.items(section)}
        if section.upper() != 'DEFAULT' :
            for k,v in self._verify_config.items('DEFAULT'):
                del dict[k]
        return dict