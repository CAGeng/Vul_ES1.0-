#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

from stonesoup.utils import texaslogging

import subprocess
import os
import abc
import sys
import re
from pprint import pformat


class InputError(Exception):
    """
    InputError Execption for bad commands
    """
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class CommandIOError(Exception):
    """
    Command Error Exception for bad commands
    """
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class BaseCommand:
    __metaclass__ = abc.ABCMeta
    """
    Generic threaded subprocess handler
    after init call parallel() to run threaded call serial()
    if you want a non threaded blocking run

    Attributes:
        cwd: Directory where subprocess should execute command from
        log_dir: name of log directory
        envvars: a dictionary of enviromental vars to be passed to POPEN
            {"SS_TC_DEPS":"/opt/stonesoup/deps"}
    """
    def __init__(self, **kwargs):
        self._cwd = kwargs.pop('cwd', './')
        self._num = 0
        self._log_dir = kwargs.pop('log_dir', 'logs')
        self._envvars = kwargs.pop('envvars', dict())
        self._id = kwargs.pop('id', None)
        self._pid = None
        self._returncode = None
        self._exec_process = None
        self._stop = False
        #self.expand_envvars()
        self.gen_standard_names()
        self._killed = False
        self._envvars["SS_LOG_{}_STDOUT".format(
            str(self._get_log_file_prefix()).upper())] = os.path.join(
                self._log_dir, self.get_stdout_name())
        self._envvars["SS_LOG_{}_STDERR".format(
            str(self._get_log_file_prefix()).upper())] = os.path.join(
                self._log_dir, self.get_stderr_name())

    def __str__(self):
        """
        Allow check of instance vars

        Returns:
            Returns a string of instance vars
        """
        my_parms = (self._cwd, self._envvars,
                    self._log_dir)
        return str.replace(str(my_parms), "\'", '\"')

    def __counter(self):
        """
        Return a counter

        Returns:
            Returns a single int for example: 0
        """
        self._num += 1
        texaslogging.debug("{}, counter() value is {}".format(
            self._get_process_name().title(), self._num))
        return self._num

    @abc.abstractmethod
    def _get_log_file_prefix(self):
        """
        Placeholder to be overridden
        """
        return

    def get_delay_command(self, delay_seconds):
        if delay_seconds is not None and delay_seconds > 0 :
            return "{0} {1}".format('sleep', delay_seconds)
        else:
            return ''

    def _get_command(self, command):
        """
        To be overridden and called by process classes
        Modifies command with delay_before and delay_after
        Should return command string to run
        """
        # If defined, add delay_before and delay_after as bash sleep commands.
        delay = self.get_delay_command(self.delay_before)
        if len(delay) > 0:
            texaslogging.info("{} inserting delay_before of {} seconds".format(
                self._get_process_name().title(), self.delay_before))
            command = "{}; {}".format(delay, command)
        delay = self.get_delay_command(self.delay_after)
        if len(delay) > 0:
            texaslogging.info("{} inserting delay_after of {} seconds".format(
                self._get_process_name().title(), self.delay_after))
            command = "{}; {}".format(command, delay)

        return command

    def _get_process_name(self):
        """
        Returns _proc_name
            Returns:
                returns self._proc_name as string
        """
        proc_name = self._id if self._id is not None else self._proc_name
        return proc_name

    def get_log_dict(self):
        """
        Retruns information on process, logs files, pid, return codes and status
            Args: None
            Returns: Dict object with pid, stdout file, stderr file, killed,
                return code
            Raises: None
        """
        self.wait()
        log_dict = {self._get_process_name(): {
            "pid": self.get_pid(), "return_code": self.get_return_code(),
            "stdout": os.path.join(self._log_dir, self.get_stdout_name()),
            "stderr": os.path.join(self._log_dir, self.get_stderr_name()),
            "killed": self._killed}}
        texaslogging.debug("{}, get_log_dict() value is {}".format(
            self._get_process_name().title(), pformat(log_dict)))
        return log_dict

    def gen_standard_names(self):
        """
        Generate a unique filename and ensure directories exist to write to
        File names will contain the process that called it, the command,
        and if its stdout or stderr
        """

        # ensure directories exist
        if os.path.exists(self._log_dir) is False:
            try:
                os.makedirs(self._log_dir)
            except (IOError, OSError) as e:
                raise CommandIOError(
                    'Bad file paths writing out stdout, stderr {}'.format(e)), \
                    None, sys.exc_info()[2]

        # write file and ensure we don't clobber an existing one
        self._proc_name = self._get_log_file_prefix()
        rname = "{}-{}.stdout".format(self._proc_name, self._num)
        try:
            while os.path.exists(os.path.join(self._log_dir, rname)) is True:
                # append a number to the front and try again
                # no change on first iter, resets to known good on following try
                rname = "{}-{}.stdout".format(self._proc_name, self.__counter())
            self._proc_name = "{}-{}".format(self._proc_name, self._num)
            texaslogging.debug("{}, gen_standard_names() touched\
                               \n{}\n{}".format(
                                            self._get_process_name().title(),
                                            os.path.join(self._log_dir,
                                                     self.get_stdout_name()),
                                            os.path.join(self._log_dir,
                                                     self.get_stderr_name())))
            open(os.path.join(
                self._log_dir, self.get_stdout_name()), "w", 0).close()
            open(os.path.join(
                self._log_dir, self.get_stderr_name()), "w", 0).close()
        except (IOError, OSError) as e:
            raise InputError('Unable to write log file, {}'.format(e)), None, \
            sys.exc_info()[2]

    def get_return_code(self, wait=True):
        """
        Return the commands return code

        Args:
            Wait: Boolean, default is True Prevent a race condition and block
                if return code has yet to return. Setting to False may return
                None Object, Wait loop sleeps for 0.05 sec

        Returns:
            Returns an int Ex: 0 or Python None object
        """
        if wait is True:
            self.wait()
        return self._returncode

    def get_pid(self):
        """
        Return the commands PID

        Args:
            None

        Returns:
            Returns an int Ex: 31337 or Python None Object
        """
        if self._pid:
            return int(self._pid)
        else:
            return 0

    def get_stdout_name(self):
        """
        Return the stdout logfile name

        Args:
            Wait: Boolean, default is True Prevent a race condition and block
                if return code has yet to return. Setting to False may return
                None Object, Wait loop sleeps for 0.05 sec

        Returns:
            Returns a string
        """
        return "{}.stdout".format(self._get_process_name())

    def get_stderr_name(self):
        """
        Return the stderr logfile name

        Args:
            Wait: Boolean, default is True Prevent a race condition and block
                if return code has yet to return. Setting to False may return
                None Object, Wait loop sleeps for 0.05 sec

        Returns:
            Returns a string
        """
        return "{}.stderr".format(self._get_process_name())

    def expand_variable(self, var):
        """
        Utilize system echo command to expand system vars

        Args:
            env_var: environment var to expand, pass as a string
                Ex: "SS_TC_DEPS"

        Returns:
            returns expanded environment var as a string
                EX: "/opt/stonesoup/deps"

        Raises:
            InputError if OSError is raised when command attempts to execute
        """
        var_orig = None
        while var_orig != var:
            var_orig = var
            for env_var in sorted(self._envvars, key=len, reverse=True):
                replacement = self._envvars[env_var]
                pattern = '(\$\{{{0}\}})|(\${0})'.format(env_var)
                var = re.sub(pattern, replacement, var_orig)
                if var != var_orig:
                    break

            # var = re.sub('(\$\{{{0}\}})|(\${0})'.format(
            #     env_var), self._envvars[env_var], var)

        return var

    def expand_envvars(self):
        """
        Replaces envvar value with expanded version
        """
        # Needs _envvars to be ordered dictionary,so dependencies are met.
        try:
            for var in self._envvars:
                self._envvars[var] = self.expand_variable(var)
        except Exception as e:
            raise e, None, sys.exc_info()[2]

    def _command_args(self):
        """
        Generic command_args for use in subprocess
        This can be overloaded by other classes
        Args:
            kill: set to true if calling from kill(), this avoids blowing reopen
                ing and blowing away the logs for the process

        Returns:
            Returns cmd_args as a dict to be used as kwargs
        """
        stdout = os.path.join(self._log_dir, self.get_stdout_name())
        stderr = os.path.join(self._log_dir, self.get_stderr_name())
        cmd_args = dict()
        cmd_args['stdout'] = open(stdout, 'w', 0)
        cmd_args['stderr'] = open(stderr, 'w', 0)
        cmd_args['cwd'] = self._cwd
        cmd_args['env'] = self._envvars
        texaslogging.debug(
            '{}, command_args is passing {} to subprocess'.format(
                self._get_process_name().title(), pformat(cmd_args)))
        return cmd_args

    def run(self):
        """
        Execute commands using subprocess, after execution
        self.pid and self.returncode will have values.
        This must be called to run your command provided at the init

        Raises:
            CommandIOError if OSError is raised when command attempts to execute
        """
        texaslogging.info("{} is running".format(
            self._get_process_name().title()))
        subprocess_kwargs = self._command_args()
        try:
            self._exec_process = subprocess.Popen(self._get_command(),
                                                  **subprocess_kwargs)
            self._pid = self._exec_process.pid
        except OSError as e:
            if not self._killed:
                texaslogging.error(
                    "{}, bad command or file does not exist, {}".format(
                        self._get_process_name().title(),
                        pformat(self._get_command())))
                raise CommandIOError(
                    "{1:s} bad command, file or command doesnt exist, \
                    {0:s}".format(e, pformat(self._get_command()))), None, \
                    sys.exc_info()[2]
            else:
                pass

        finally:
            if subprocess_kwargs is not None:
                if 'stdout' in subprocess_kwargs:
                    if hasattr(subprocess_kwargs['stdout'], 'close'):
                        subprocess_kwargs['stdout'].close()
                if 'stderr' in subprocess_kwargs:
                    if hasattr(subprocess_kwargs['stderr'], 'close'):
                        subprocess_kwargs['stderr'].close()

    def kill(self, pid_file=None):
        """
        Kill a running subprocess

        Returns:
            Returns None object
        """
        if self._exec_process is not None and self._exec_process.poll() is None:
            self._killed = True
            texaslogging.info('{} killed its process'.format(
                self._get_process_name().title()))
            try:
                #self._exec_process.kill()
                if self._pid is not None:
                    killtree_pid_args = '-p {}'.format(self._pid)
                    if pid_file is not None:
                        killtree_pid_args = '-d -f "{}"'.format(pid_file)

                    command = 'killtree.sh {}'.format(killtree_pid_args)

                    stdout = "{}/{}_killtree".format(self._log_dir,
                                                     self.get_stdout_name())
                    stderr = "{}/{}_killtree".format(self._log_dir,
                                                     self.get_stderr_name())
                    subprocess_kwargs = dict()
                    subprocess_kwargs['cwd'] = self._cwd
                    subprocess_kwargs['env'] = self._envvars
                    subprocess_kwargs["executable"] = '/bin/bash'
                    subprocess_kwargs['shell'] = True
                    subprocess_kwargs['stdout'] = open(stdout, 'w', 0)
                    subprocess_kwargs['stderr'] = open(stderr, 'w', 0)

                    kill_process = subprocess.Popen(command,
                                                    **subprocess_kwargs)
                    kill_process.wait()
                    if self._returncode is None:
                        # process was still running, mark as SIGTERM
                        self._returncode = 136
            except OSError as e:
                sys.stderr.write(e.message)
                texaslogging.error("{}, failed to kill process {}".format(
                    self._get_process_name().title(),
                    pformat(self._get_command())))
                raise CommandIOError(
                    "Exception: unable to kill command '{0:s}'".format(
                        e, ' '.join(self._get_command()))), None, \
                    sys.exc_info()[2]


    # Support smooth termination
    def stop(self):
        """
        Sets a signal on which process polls,
        to then invoke it's specific kill process.
        """
        self._stop = True

    def start(self):
        """
        Call run, to support code that expects this to be threaded

        Args:
            None
        Returns:
            None
        """
        self.run()

    def wait(self):
        """
        Wait for a running subprocess to complete

        Returns:
            Returns None object
        """
        if self._exec_process is not None:
            self._exec_process.wait()
            self._returncode = self._exec_process.returncode

    def join(self):
        """
        Call wait, to support code that expects this to be threaded

        Returns:
            None
        """
        self.wait()

