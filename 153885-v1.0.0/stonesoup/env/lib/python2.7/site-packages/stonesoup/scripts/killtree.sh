#!/bin/bash
# ------------------------------Copyright-------------------------------------
# NOTICE
# 
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
# 
# Copyright (c) 2014 Ponte Technologies. All Rights Reserved.
# -----------------------------Copyright--------------------------------------


#=== Section =================================================================
#
# Functions
#
#=============================================================================
#### Function ################################################################
# Print an error message to stderr.
# Globals:
#   None
# Arguments:
#   Strings to print
# Returns:
#   None
##############################################################################
function print_error() {
    echo "$@" >&2
}

#### Function ################################################################
# Print script usage.
# Globals:
#   $0 - Script name
# Arguments:
#   None
# Returns:
#   None
##############################################################################
function print_usage() {
    cat << EOF
usage: $0 [-d] [-s SIGNAL] -p PID
       $0 [-d] [-s SIGNAL] -f PID_FILE

This script provides an interface through which a target application can be 
executed.  Commands will be evaluated by the SHELL to simulate executing
what would otherwise be provided by a user on the command line.   

OPTIONS:
   -d      DO NOT kill the specified PID, only it's children.
   
   -f      PID file

   -h      Show this message.
           
   -p      PID
   
   -s      Kill signale, defaults to 9.
EOF
}

#### Function ################################################################
# Recursively kills the target pid and all children, grandchildren, etc.
# All processes in the tree rooted at PID are killed from the bottom up.  Thus,
# the target root PID will be killed last.  Finally, each process in the tree 
# is stopped before the children (if any) are killed.  This is to prevent a 
# parent process from re-spawning a killed child.
# Globals:
#   KILL_SIGNAL
#   ROOT_PID
#   MODE_KILL_CHILDREN_ONLY
# Arguments:
#   Root Process PID
# Returns:
#   None
##############################################################################
kill_tree_internal() {
    local parent_pid="${1}"
    local child_pid=""
    local parent_pid_killed=""
    
    # Check if we should kill the ROOT_PID specified on the command line
    #if [[ "${parent_pid}" -ne "${ROOT_PID}" || "${MODE_KILL_CHILDREN_ONLY}" == "no" ]]
    #then
        # Stop the parent before killing children.  This is required because 
        # some target processes attempt to automatically re-spawn their children
        # to heal a failure.
    #   printf "Stopping %s, state=%s, command: %s\n" \
    #        "${parent_pid}" \
    #        "$(ps -p ${parent_pid} -o state=)" \
    #        "$(ps -p ${parent_pid} -o command=)"
    #    kill -s STOP "${parent_pid}"
    #    sleep 1
    #fi
    
    # Iterate over children first. We only need the child pid, so
    # specify a custom format to avoid grep, cut, etc.
    for child_pid in $(ps --ppid "${parent_pid}" -o pid=)
    do
        # we recursively kill the children first, so the parent exits last
        kill_tree_internal "${child_pid}"
    done
    
    
    # Check if we should kill the ROOT_PID specified on the command line
    if [[ "${parent_pid}" -ne "${ROOT_PID}" || "${MODE_KILL_CHILDREN_ONLY}" == "no" ]]
    then
        # Print that we are killing the parent_pid, since we have now 
        # recursively killed any children
        printf "Killing %s, state=%s, command: %s\n" \
            "${parent_pid}" \
            "$(ps -p ${parent_pid} -o state=)" \
            "$(ps -p ${parent_pid} -o command=)"

        kill -s "${KILL_SIGNAL}" "${parent_pid}"

        # Kill is asynchronous, wait for the target PID to exit.  This is not 
        # the best way to check if it has exited because of the sleep, but it 
        # works for the time being.
        while kill -0 "${parent_pid}" 1>/dev/null 2>&1
        do
            # Check if defunct
            if [[ $(ps h -p "${parent_pid}" -o stat) =~ ^Z ]]
            then
                break
            fi
            printf "Waiting on %s, state=%s\n" \
                "${parent_pid}" \
                "$(ps -p "${parent_pid}" -o state=)"
            sleep 0.5
        done
	fi

}


#=== Section =================================================================
#
# Main Script
#
#=============================================================================
ROOT_PID=""
ROOT_PID_FILE=""

# Parse the arguments
while getopts “hs:p:f:d” OPTION
do
    case $OPTION in
        h)
            print_usage
            exit 0
            ;;
        s)
            KILL_SIGNAL="${OPTARG}"
            ;;
        p)
            ROOT_PID="${OPTARG}"
            ;;
        f)
            ROOT_PID_FILE="${OPTARG}"
            ;;
        d)
            MODE_KILL_CHILDREN_ONLY="yes"
            ;;
        ?)
            print_usage
            exit 1
            ;;
    esac
done

# Apply defaults to all arguments not specified
MODE_KILL_CHILDREN_ONLY="${MODE_KILL_CHILDREN_ONLY:-no}"
KILL_SIGNAL="${KILL_SIGNAL:-KILL}"

if [[ -z "${ROOT_PID}" && -z "${ROOT_PID_FILE}" ]]
then
    print_error "No PID specified."
    exit 1
fi

# If the PID is in a file, grab it.
if [[ ! -z "${ROOT_PID_FILE}" ]]
then
    ROOT_PID="$(cat "${ROOT_PID_FILE}")"
fi

# Start the kill
kill_tree_internal "${ROOT_PID}"