from stonesoup.database import *
from progressbar import AnimatedMarker, ProgressBar, Timer
from bson import ObjectId
from time import sleep
import os
import sys
import threading
import argparse
import shutil
import signal

local_module = sys.modules[__name__]

class DownloadTimer(threading.Thread):
    def __init__(self, **kwargs):
        threading.Thread.__init__(self)
        self.fd = kwargs.pop('timer_fd', None)
        self.daemon = True
        self._stop = threading.Event()
        self._stopping = threading.Event()
        self._widget_string = kwargs.pop("widget_string", "Downloading")

    def run(self):
        self._stop.clear()

        widgets = ['{}: '.format(self._widget_string), AnimatedMarker(), ' ', Timer()]
        pbar = ProgressBar(widgets=widgets).start()
        while not self._stop.isSet():
            sleep(.5)
            pbar.update()
        pbar.finish()

    def stop(self):
        self._stop.set()
        sleep(2)

def subcommand_args_not_implemented(parser):
    """Raises an error that the parser is not implemented when called
    Args:
        parser: an argparse ArgumentParser
    Returns:
        None.
    Raises:
        NotImplementedError: sub-command not implemented.
    """
    raise NotImplementedError('sub-command not implemented.'), None, sys.exc_info()[2]


def load_database(args):
    db_addr = args.IP
    db_port = args.PORT

    database.create(address=db_addr, port=int(db_port))

def subcommand_args_common(parser):

    parser.add_argument('-i', '--ip', dest="IP",
                        required=True, default="127.0.0.1",
                        help="IP of the database to connect to.")

    parser.add_argument('--port', dest="PORT",
                        required=False, default=27017, type=int,
                        help="Port of the database to connect to. (Default: 27017)")



def subcommand_args_testcase(parser):


    subcommand_args_common(parser)

    parser.add_argument("-t", "--testcases", dest="testcases",
                        nargs="+", default=[], required=True,
                        help="Testcases to pull from the database.")

    parser.add_argument("-q", "--queue", dest="queue_name",
                        required=True, default=[],
                        help="Queue name to pull testcases from.")

    parser.add_argument("-a", "--analyze", dest="analyze",
                        required=False, default=False,
                        action="store_true",
                        help = "Pull analyze runs from the testcases.")

    parser.add_argument("-e", "--execute", dest="execute",
                        required=False, default=True,
                        action="store_true",
                        help="Pull execute runs from the testcases.")

    parser.add_argument("--type", dest="type",
                        required=False, default="passed",
                        choices=['passed', 'failed', 'both'],
                        help="Type of testcases to pull down")

    parser.add_argument("-v", "--verbose", dest="verbose",
                        required=False, default=False,
                        action="store_true",
                        help = "Get verbose output.")

    parser.add_argument("--orig", "--original", dest="original",
                        required=False, default=False, action="store_true",
                        help="Get the original testcases.")

    parser.add_argument("-o", "--output-dir", dest="location",
                        default=os.getcwd(), required=False,
                        help="Output directory to store the files at.")

    parser.add_argument("--uniq", dest="unique",
                        required=False, default=False,
                        action="store_true",
                        help ="Only get one instance of an iopair.(Useful only with performer [Stage 2] runs)")

    parser.add_argument("-p", "--performer", dest="performer",
                        required=False, default=False,
                        action="store_true",
                        help="Pull down only performer (Stage 2) testcase runs.")
    
    parser.add_argument("-ne", "--no-execute", dest="no_execute",
                        required=False, default=False,
                        action="store_true",
                        help="Skip execute runs (Execute enabled by default)")
    parser.set_defaults(handler=subcommand_testcase)


def subcommand_testcase(args):

    load_database(args)

    queue = DbQueue.get_queue(args.queue_name)
    if args.unique and not args.execute:
        raise DatabaseError("Cannot get unique iopair runs without specifying execute runs."), None, None

    if queue is None:
        raise DatabaseError("Queue '{}' does not exist.".format(args.queue_name)), None, None
    testcases = list()
    non_existent = list()
    for testcase in args.testcases:
        database_testcase = database.find_one(DbTestcase.collection(),
                                              {'name' : testcase})

        if database_testcase is None:
            non_existent.append(testcase)

        testcases.append(database_testcase)


    if len(non_existent) > 0:
        print "These testcases were not found in the database: {}".format(",".join(non_existent))
        print "You may want to make sure they have been loaded before pulling them down."
        print "Exiting.."
        return

    get_testcases_and_runs(args, queue, testcases)


def get_testcases_and_runs(args, queue, testcases):
    #the order for testcase names is:
    #{testcase_name : [ [analyze_run_ids], num_times_in_queue] }
    testcase_names = dict()
    for testcase in testcases:
        db_testcase = DbTestcase.load_testcase(testcase)

        if db_testcase is None:
            raise DatabaseError("Unable to get testcase from the database."), None, None
        query = {'tc_id' : db_testcase.id,
                 'queue_id' : queue.id}
        if args.performer:
            print "Searching for only performer (Stage 2) runs for testcase: {}".format(db_testcase.name)
            query.update({'performer' : True})
        analyze_run_ids = database.find(DbAnalyzeRun.collection(),
                                        query)
        if analyze_run_ids.count() == 0:
            if args.verbose:
                print "Testcase '{}' does not have any runs for our given queue\
and will not be added to the list of archives to pull down.".format(db_testcase.name)

            continue
        testcase_names[db_testcase.name] = [ analyze_run_ids.distinct('_id'),
                                             analyze_run_ids.count()]


    db_testcases = get_single_testcase_run(testcase_names)

    #get each of the analyze and execute runs.
    location = args.location
    location = os.path.abspath(location)

    for key in db_testcases:

        analyze_run_id = db_testcases[key]

        analyze_run = DbAnalyzeRun.load_object(analyze_run_id)

        if args.original:
             print "Downloading testcase archive: {}".format(analyze_run.testcase.name)
             download_object(analyze_run.testcase, location,
                            widget_string="Downloading Testcase")

        if args.analyze:
            get_analyze_run(analyze_run, location, args.type, key, args.verbose)

        #Execute runs will get loaded later
        #if we end up needing to load them
        if args.execute and not args.no_execute:
            query = {'queue_id' : queue.id,
                     'analyze_run_id' : analyze_run_id}


            execute_runs_list = database.find(DbExecuteRun.collection(),
                                              query)

            execute_runs = []
            if args.unique:
                #get a list of unique io_pairs based on the type of runs the user wants.
                execute_runs =  get_unique_iopair_runs(execute_runs_list, args.type, args.verbose)
            else:
                execute_runs = execute_runs_list

            for execute_run in execute_runs:
                get_execute_run(execute_run, location, args.type, key, args.verbose)

def get_single_testcase_run(testcase_names=dict()):
    db_testcases = dict()
    for key in testcase_names.keys():
        if testcase_names[key][1] > 1:
            print "Testcase '{}' contains multiple runs in the queue, which one would you like?".format(key)
            print "Runs:"
            print "----------------------------------------"
            x = 1
            for run_id in testcase_names[key][0]:
                analyze_run = DbAnalyzeRun.load_object(run_id)
                name = analyze_run.testcase.name

                performer_text = ""

                if analyze_run.performer:
                    performer_text  += "- PERFORMER RUN"
                else:
                    performer_text += "- STAGE 1 RUN"

                if analyze_run.debug:
                    performer_text += "- DEBUG"

                if analyze_run.verbose:
                    performer_text += "- VERBOSE"

                if analyze_run.dryrun:
                    performer_text += "- DRY RUN"

                if analyze_run.release:
                    performer_text += "- RELEASE MODE"

                performer_text = "\033[31;1m{}\033[0;0m".format(performer_text)
                print "{0}) {1} {2}".format(x, name, performer_text)
                x+=1

            print "----------------------------------------"
            testcase_num = int(raw_input("What testcase would you like? (Pick a number):")) -1
            db_testcases[key] = testcase_names[key][0][testcase_num]
        else:
            db_testcases[key] = testcase_names[key][0][0]
    return db_testcases


def get_analyze_run(analyze_run, location, download_type="passed", testcase_name="", verbose=False):
    passed = True if download_type == 'passed' or \
                     download_type == 'both' \
                  else False
    failed = True if download_type == 'failed' or \
                     download_type == 'both' \
                  else False
    failed_loc, passed_loc, skipped_loc = get_paths(location, testcase_name)
    try:
        if passed and analyze_run.result is True:
            if verbose:
                print "Downloading analyze run for testcase: {}".format(testcase_name)
            download_object(analyze_run, passed_loc, widget_string=testcase_name)
            return

        if failed and not analyze_run.result is True:
            if analyze_run.result == 'skip':
                download_object(analyze_run, skipped_loc, widget_string=testcase_name)
            else:
                download_object(analyze_run, failed_loc, widget_string=testcase_name)
            return
        if verbose:
            print "We have skipped over the analyze run for: {}. This was because:".format(testcase_name)
            if download_type is 'both':
                print "You labeled download type as both and we ran into some unknown issue."
            elif analyze_run.result is None:
                print "The analyze run has not been completed yet and the tarball does not exist."
            elif passed and  not analyze_run.result and not failed:
                print "You selected only passed runs and the run indicated a {}".format('failure' \
                                                                                        if not analyze_run.result\
                                                                                        else 'skip')
            elif failed and analyze_run.result and not passed:
                print "You selected only failed runs and the run was successful."
            else:
                print "We have reached a bad place. Check the database for more information."

    except Exception, e:
        raise DatabaseError(e.message)

def get_execute_run(execute_run, location, download_type="passed", testcase_name="", verbose=False):
    passed = True if download_type == 'passed' or \
                     download_type == 'both' \
                  else False

    failed = True if download_type == 'failed' or \
                     download_type == 'both' \
                  else False

    failed_loc, passed_loc, skipped_loc = get_paths(location, testcase_name)

    run = DbExecuteRun.load_object(execute_run)
    try:
        if run is None:
            raise DatabaseError("Issue finding execute run with id: {}. Please check the Database.".format(execute_run['_id']))

        if passed and run.result is True:
            download_object(run, passed_loc, widget_string=run.iopair.name)
            return

        if failed and not run.result is True:
            if run.result == 'skip':
                download_object(run, skipped_loc, widget_string=run.iopair.name)
            else:
                download_object(run, failed_loc, widget_string=run.iopair.name)
            return
        if verbose:
            print "We have skipped over execute run {}. This was because:".format(run.iopair.name)
            if download_type is 'both':
                print "You labeled download type as both and we ran into some unknown issue."
            elif run.result is None:
                print "The execute run has not been completed yet and the tarball does not exist. It may have exceeded the maximum size saved to the database."
            elif passed and not run.result and not failed:
                print "You selected only passed runs and the run indicated a {}".format('failure' \
                                                                                        if not run.result\
                                                                                        else 'skip')
            elif failed and run.analyze_run.result and not passed:
                print "You selected only failed runs and the run was successful."
            else:
                print "We have reached a bad place. Check the database for more information."

    except Exception, e:
        raise DatabaseError(e.message)


def get_unique_iopair_runs(execute_run_list, download_type="passed", verbose=False):
    if verbose:
        print "Detected unique flag. Trying to determine best execute runs for our list of io_pairs"
    io_ids = execute_run_list.distinct('io_id')
    #sort on ordinal ascending.
    io_pairs = database.find(DbIoPair.collection(),
                             {'_id' : {'$in' : io_ids}})


    execute_run_list.sort('ordinal', 1)
    unique_run_dict = dict()
    for run in execute_run_list:
        if run['io_id'] in io_ids:
            io_id = run['io_id']
            if download_type == "passed" and run['result'] is True:
                io_ids.remove(io_id)
                unique_run_dict[io_id] = run['_id']
            elif download_type == 'failed' and not run['result'] is True:
                io_ids.remove(io_id)
                unique_run_dict[io_id] = run['_id']
            elif download_type == 'both':
                io_ids.remove(io_id)
                unique_run_dict[io_id] = run['_id']
            else:
                continue
    execute_runs = list()
    for key in sorted(unique_run_dict.keys()):
        execute_runs.append(unique_run_dict[key])

    return execute_runs
def get_paths(location, testcase_name):
    failed_loc = os.path.join(location, "failed")
    failed_loc = os.path.join(failed_loc, testcase_name)

    passed_loc = os.path.join(location, "passed")
    passed_loc = os.path.join(passed_loc, testcase_name)

    skipped_loc = os.path.join(location, 'skipped')
    skipped_loc = os.path.join(skipped_loc, testcase_name)

    return failed_loc, passed_loc, skipped_loc

def download_object(db_object, location,  widget_string="Downloading"):

    if not os.path.exists(location):
        os.makedirs(location)
    pbar = DownloadTimer(widget_string=widget_string)
    pbar.start()
    if db_object.archive is None:
        pbar.stop()
        sleep(1)
        print "The run has been marked for download, but there's no archive!"
        if hasattr(db_object, 'io_id'):
            io_pair = DbIoPair.load_object(db_object.io_id)
            print "The io_pair related to this object is: {}".format(io_pair.name)
        elif hasattr(db_object, 'iopair'):
            print "The io_pair related to this object is: {}".format(db_object.iopair.name)
        elif hasattr(db_object, 'name'):
            print "{} had no archive instance.".format(db_object.name)
        elif hasattr(db_object, 'testcase'):
            print "{} may not have been run yet..".format(db_object.testcase.name)
        else:
            print "We couldn't find more information on this tarball. Please check the db for more info."

        if db_object.result is None:
            print "It is possible this object has not been run yet!"
        return
    archive_loc = db_object.archive.get_archive()
    pbar.stop()
    shutil.copy(archive_loc, location)
    os.remove(archive_loc)
    sleep(1)
    print "Archive saved to {}/{}".format(location, archive_loc.split('/')[2])


def signal_handler(signal, frame):
    print("\nYou have pressed CTRL-C. Program exiting.")
    sys.exit(0)




def main():
    signal.signal(signal.SIGINT, signal_handler)
    parser = argparse.ArgumentParser(prog="texasdb_archive")

    subcommand_args_testcase(parser)

    args = parser.parse_args()
    args.handler(args)


if __name__ == '__main__':
    main()
