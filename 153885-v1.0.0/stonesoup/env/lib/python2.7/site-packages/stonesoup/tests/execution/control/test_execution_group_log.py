# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
import os
import sys
import shutil
import unittest

from stonesoup.metadata import ExecutionGroup as ProcessGroup
from stonesoup.metadata import ExecutionSchemeType
from egtestfunctions import ExecutionGroupTestFunctions


class TestExecutionGroupLog(unittest.TestCase):

    def setUp(self):
        """Instantiate the utility class.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
        """
        self.func = ExecutionGroupTestFunctions()
        self.kwargs = self.func.kwargs

    def tearDown(self):
        """Remove all test artifacts.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
        """
        if os.path.exists(self.func.outdir):
            shutil.rmtree(self.func.outdir)

    def test_Log_P0sss1(self):
        """Test log dictionary using a parallel flow with scripts P{sss}."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg1.inputs.append(input[0])
        eg1.inputs.append(input[1])
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        
    def test_Log_S0sss1(self):
        """Test log dictionary using a serial flow with scripts S{sss}."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg1.inputs.append(input[0])
        eg1.inputs.append(input[1])
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_S0P0ss1s1(self):
        """Test log dictionary using: under a serial flow, a parallel subflow with scripts S{P{ss}s}."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[0])
        eg2.inputs.append(input[1])
        eg1.inputs.append(eg2)
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_S0sP0ss11(self):
        """Test log dictionary using: under a serial flow, a process and a parallel subflow with scripts."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg1.inputs.append(input[0])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[1])
        eg2.inputs.append(input[2])
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_S0S0ss1s1(self):
        """Test log dictionary using: under a serial flow, a serial subflow and a process."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[0])
        eg2.inputs.append(input[1])
        eg1.inputs.append(eg2)
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_S0sS0ss11(self):
        """Test log dictionary using: under a serial flow, a process and a serial subflow."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg1.inputs.append(input[0])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[1])
        eg2.inputs.append(input[2])
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_P0P0ss1s1(self):
        """Test log dictionary using: under a parallel flow, a parallel subflow P{P{ss}s} and a process."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[0])
        eg2.inputs.append(input[1])
        eg1.inputs.append(eg2)
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_P0sP0ss11(self):
        """Test log dictionary using: under a parallel flow, a process and a parallel subflow."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg1.inputs.append(input[0])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[1])
        eg2.inputs.append(input[2])
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_P0S0ss1s1(self):
        """Test log dictionary using: under a parallel flow, a serial subflow and a process."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[0])
        eg2.inputs.append(input[1])
        eg1.inputs.append(eg2)
        eg1.inputs.append(input[2])
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_P0sS0ss11(self):
        """Test log dictionary using: under a parallel flow, a process and a serial subflow."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(3)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(3, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg1.inputs.append(input[0])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[1])
        eg2.inputs.append(input[2])
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])

    def test_Log_P0P0ss1P0ss11(self):
        """Test log dictionary using: under a parallel flow, two parallel subflows P{P{ss}P{ss}}."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_P0P0ss1S0ss11(self):
        """Test log dictionary using a parallel flow with parallel and serial subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_P0S0ss1P0ss11(self):
        """Test log dictionary using a parallel flow with serial and parallel subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_P0S0ss1S0ss11(self):
        """Test log dictionary using a parallel flow with two serial subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_S0P0ss1P0ss11(self):
        """Test log dictionary using a serial flow with two parallel subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_S0P0ss1S0ss11(self):
        """Test log dictionary using a serial flow with parallel and serial subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_S0S0ss1P0ss11(self):
        """Test log dictionary using a serial flow with serial and parallel subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_S0S0ss1S0ss11(self):
        """Test log dictionary using a serial flow with serial subprocesses."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(4)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(4, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[2])
        eg2.inputs.append(input[3])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])

    def test_Log_P0S0ss1P0S0ss1s11(self):
        """Test log dictionary using a parallel flow with three process levels."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(5)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(5, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg4 = ProcessGroup(ExecutionSchemeType.sequence)
        eg4.inputs.append(input[2])
        eg4.inputs.append(input[3])
        eg2.inputs.append(eg4)
        eg2.inputs.append(input[4])
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])
        self.assertEquals(log_dict['test5']['stdout'], output[4][0])
        self.assertEquals(log_dict['test5']['stderr'], output[4][1])

    def test_Log_S0S0ss1S0sP0ss111(self):
        """Test log dictionary using a serial flow with three process levels."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(5)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(5, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg3.inputs.append(input[1])
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(input[2])
        eg4 = ProcessGroup(ExecutionSchemeType.parallel)
        eg4.inputs.append(input[3])
        eg4.inputs.append(input[4])
        eg2.inputs.append(eg4)
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])
        self.assertEquals(log_dict['test5']['stdout'], output[4][0])
        self.assertEquals(log_dict['test5']['stderr'], output[4][1])

    def test_Log_P0S0sP0ss11P0sS0ss111(self):
        """Test log dictionary using a parallel flow with three process levels."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(6)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(6, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.parallel)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg4 = ProcessGroup(ExecutionSchemeType.parallel)
        eg4.inputs.append(input[1])
        eg4.inputs.append(input[2])
        eg3.inputs.append(eg4)
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[3])
        eg5 = ProcessGroup(ExecutionSchemeType.sequence)
        eg5.inputs.append(input[4])
        eg5.inputs.append(input[5])
        eg2.inputs.append(eg5)
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])
        self.assertEquals(log_dict['test5']['stdout'], output[4][0])
        self.assertEquals(log_dict['test5']['stderr'], output[4][1])
        self.assertEquals(log_dict['test6']['stdout'], output[5][0])
        self.assertEquals(log_dict['test6']['stderr'], output[5][1])

    def test_Log_S0S0sP0ss11P0sS0ss111(self):
        """Test log dictionary using a serial flow with three process levels."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create script Input object
        input = self.func.get_script_input(6)

        # Get paths of stdout and stderr log files of script processes.
        output = self.func.get_output_path_from_id(6, 'test', 'log')

        # Compose and run the ExecutionGroup
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3 = ProcessGroup(ExecutionSchemeType.sequence)
        eg3.inputs.append(input[0])
        eg4 = ProcessGroup(ExecutionSchemeType.parallel)
        eg4.inputs.append(input[1])
        eg4.inputs.append(input[2])
        eg3.inputs.append(eg4)
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(input[3])
        eg5 = ProcessGroup(ExecutionSchemeType.sequence)
        eg5.inputs.append(input[4])
        eg5.inputs.append(input[5])
        eg2.inputs.append(eg5)
        eg1.inputs.append(eg3)
        eg1.inputs.append(eg2)
        eg_obj = self.func.run_execution_group(eg1)

        # Check that the log dictionary has the paths expected from the configuration and script ids.
        log_dict = eg_obj.get_log_dict()
        self.assertEquals(log_dict['test1']['stdout'], output[0][0])
        self.assertEquals(log_dict['test1']['stderr'], output[0][1])
        self.assertEquals(log_dict['test2']['stdout'], output[1][0])
        self.assertEquals(log_dict['test2']['stderr'], output[1][1])
        self.assertEquals(log_dict['test3']['stdout'], output[2][0])
        self.assertEquals(log_dict['test3']['stderr'], output[2][1])
        self.assertEquals(log_dict['test4']['stdout'], output[3][0])
        self.assertEquals(log_dict['test4']['stderr'], output[3][1])
        self.assertEquals(log_dict['test5']['stdout'], output[4][0])
        self.assertEquals(log_dict['test5']['stderr'], output[4][1])
        self.assertEquals(log_dict['test6']['stdout'], output[5][0])
        self.assertEquals(log_dict['test6']['stderr'], output[5][1])
