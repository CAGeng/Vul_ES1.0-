#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
from os.path import dirname as dirname
import sys
import shutil
import subprocess
from flexmock import flexmock
from nose.tools import assert_equal, assert_raises, assert_is_not, with_setup

from stonesoup.configuration import configuration
from stonesoup.execution.process.database import *
from stonesoup.metadata import *
from stonesoup.tests.resources import configs

def setup_test_env():
    global outdir
    outdir = os.path.join(os.path.abspath(os.sep), 'opt', 'stonesoup', 'test')
    # Set up logging
    testconf = os.path.join(dirname(configs.__file__), 'test.conf')
    configuration.create(testconf)
    texaslogging.add_logger()
    global kwargs
    process_cwd = './'
    process_envvars = {'SS_ENVVAR': 'stonesoup', 'SS_TC_ROOT': outdir}
    process_workspace_dir = outdir
    process_log_dir = os.path.join(process_workspace_dir, 'logs')
    kwargs = dict()
    kwargs['cwd'] = process_cwd
    kwargs['envvars'] = process_envvars
    kwargs['workspace_dir'] = process_workspace_dir
    kwargs['log_dir'] = process_log_dir
    kwargs['databases'] = {'POSTGRESQL': {
        'dbtype': 'postgresql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'pg'}}
    database_input_value = "test data"
    database_input_handling = ValueType.use_text
    database_input_encoding = EncodingType.string
    database_type = "postgresql"
    database_name = "testDATABASE"
    database_input_id = "database-test"
    inputs = DatabaseInput()
    inputs.value = database_input_value
    inputs.handling = database_input_handling
    inputs.encoding = database_input_encoding
    inputs._database_name = database_name
    inputs.database_type = database_type
    inputs.id = database_input_id
    kwargs['input'] = inputs

    if not os.path.exists(outdir):
        os.mkdir(outdir)

def teardown_test_env():
    if os.path.exists(outdir):
        shutil.rmtree(outdir)

@with_setup(setup_test_env, teardown_test_env)
def test_get_log_file_prefix():
    """
    Test database logfile prefix
    """
    print >> sys.stderr, sys._getframe().f_code.co_name
    kwargs['databases'] = {'mysql': {
        'dbtype': 'mysql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'mysql'}}
    kwargs['input'].database_type = 'mysql'
    db = get_database(**kwargs)
    assert_equal(db._get_log_file_prefix(), "database-testing-0")

@with_setup(setup_test_env, teardown_test_env)
def test_get_command():
    """
    Test command generation for mysql, postgresql, mssql
    """
    print >> sys.stderr, sys._getframe().f_code.co_name
    kwargs['databases'] = {'POSTGRESQL': {
        'dbtype': 'postgresql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'pg'}}
    kwargs['input'].handling = ValueType.use_text
    kwargs['input'].value = 'hello world'
    kwargs['input'].database_type = "postgresql"
    db1 = get_database(**kwargs)
    db1.sql_path = db1.make_sql_file()
    # Check we are at least getting value for dynamic name
    assert_is_not(db1.sql_path, None)
    cmd_str = db1._get_command()
    # Remove the dynamic generated file path from the check
    cmd_chk = ' '.join(cmd_str.split(' ')[:-1])
    assert_equal(cmd_chk, 'psql -h 127.0.0.1 -p 8888 -U test -f')
    shutil.rmtree(kwargs['workspace_dir'])

    # Test mysql
    kwargs['databases'] = {'mysql': {
        'dbtype': 'mysql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'mysql'}}
    kwargs['input'].handling = ValueType.use_file_contents
    kwargs['input'].value = 'hello_world.txt'
    kwargs['input'].database_type = 'mysql'
    db2 = get_database(**kwargs)
    db2.sql_path = db2.make_sql_file()
    cmd_str = db2._get_command()
    assert_equal(
        cmd_str, 'mysql -utest -ppassword')
    shutil.rmtree(kwargs['workspace_dir'])

    # Test mssql
    kwargs['databases'] = {'mssql': {
        'dbtype': 'mssql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'mssql'}}
    kwargs['input'].handling = ValueType.use_file_contents
    kwargs['input'].value = 'hello_world.txt'
    kwargs['input'].database_type = 'mssql'
    assert_raises(database.DatabaseIOException, get_database, **kwargs)

@with_setup(setup_test_env, teardown_test_env)
def test_make_file():
    """
    Test ability to make sql command file
    """
    print >> sys.stderr, sys._getframe().f_code.co_name
    # Mock subprocess
    kwargs['input'].handling = ValueType.use_text
    kwargs['input'].value = 'hello world'
    kwargs['input'].database_type = 'mysql'
    flexmock(subprocess)
    success = flexmock(name='success', returncode=0, pid=1)
    success.should_receive('wait').and_return()
    success.should_receive('communicate').and_return(('pass', 'pass'))
    subprocess.should_receive('Popen').and_return(success)
    # Run actual test
    db = get_database(**kwargs)
    db.sql_path = db.make_sql_file()
    assert_is_not(db.sql_path, None)
    with open(db.sql_path, 'r') as f:
        y = f.read()
    assert_equal(y, 'hello world')

@with_setup(setup_test_env, teardown_test_env)
def test_pgpass_file():
    """
    Test ability to read and write pg pass file
    """
    print >> sys.stderr, sys._getframe().f_code.co_name
    # Check for clean execution
    kwargs['databases'] = {'POSTGRESQL': {
        'dbtype': 'postgresql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'pg'}}
    kwargs['input'].database_type = 'postgresql'
    db = get_database(**kwargs)
    assert_equal(db.pgpass_file(), 0)
    with open(db.pgpassfile, 'r') as f:
        x = f.read()
    assert_equal('*:*:*:test:password\n', x)

@with_setup(setup_test_env, teardown_test_env)
def test_create_database():
    """
    Use flex mock to test database creation code
    """
    print >> sys.stderr, sys._getframe().f_code.co_name
    kwargs['databases'] = {'POSTGRESQL': {
        'dbtype': 'postgresql', 'user': 'test', 'password': 'password',
        'host': '127.0.0.1', 'port': '8888', 'abbr': 'pg'}}
    kwargs['input'].database_type = 'postgresql'
    success = flexmock(name='success', returncode=0, pid=1)
    success.should_receive('communicate').and_return(('pass', 'pass'))
    success.should_receive('wait').and_return()
    nothing = flexmock(name='nothing')
    flexmock(subprocess)
    subprocess.should_receive('Popen').and_return(success)
    flexmock(database.DatabasePostgresql)
    database.DatabasePostgresql.should_receive('pgpass_file').and_return(
        nothing)
    # psql
    db1 = get_database(**kwargs)
    db1.run()
    assert_equal(db1.get_log_dict()[db1._get_process_name()]['return_code'], 0)
