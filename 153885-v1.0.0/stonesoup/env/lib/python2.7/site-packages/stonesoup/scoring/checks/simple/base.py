# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
'''
Created on May 27, 2014

@author: jenn.casler
'''
import os
import base64
import random
import string
from time import sleep
from stonesoup.scoring.checks.base import Base_Operation
from stonesoup.metadata import EncodingType, ValueType, SimpleOutputCheck
from stonesoup.scoring.utils import ScoringError
from stonesoup.utils import Workspace

class Base_Simple_Operation(Base_Operation):

    def __init__(self, metadata, check):
        if not isinstance(check, SimpleOutputCheck):
            raise ScoringError('Invalid simple output check type {0:s}'.format(check))

        super(Base_Simple_Operation, self).__init__(metadata, check)
        self._value = check.value
        self._encoding = check.encoding
        self._handling = check.handling

    @property
    def value(self) :
        return self._value

    @value.setter
    def value(self, value) :
        self._value = value

    @property
    def encoding(self) :
        return self._encoding

    @encoding.setter
    def encoding(self, value) :
        if isinstance(value, basestring):
            self._encoding = EncodingType[value]
        elif isinstance(value, EncodingType):
            self._encoding = value

    @property
    def handling(self) :
        return self._handling

    @handling.setter
    def handling(self, value) :
        if isinstance(value, basestring):
            self._handling = ValueType[value]
        elif isinstance(value, ValueType):
            self._handling = value


    def get_string_as_string(self, value,  encoding=None) :
            if encoding is None or encoding == self._encoding or (self._encoding is None and encoding == EncodingType.string):
                return value
            elif encoding == EncodingType.base64 and (self._encoding == EncodingType.string or self._encoding is None):
                return base64.encodestring(value)
            else:
                return base64.decodestring(value)

    def get_string_as_file(self, value, encoding=None):
        filename = Workspace.make_rel_path_abs(os.path.join(Workspace.get_log_dir(), "temp{0}_{1}.txt".format(self.__class__.__name__, self._get_random_string())))
        with open(filename, "w") as f:
            if encoding is None or encoding == self._encoding or (self._encoding is None and encoding == EncodingType.string):
                f.write(value)
            elif encoding == EncodingType.base64 and (self._encoding == EncodingType.string or self._encoding is None):
                f.write(base64.encodestring(value))
            else:
                f.write(base64.decodestring(value))

        sleep(.2)
        return filename

    def get_file_as_string(self, value, encoding=None):
        string_value = None

        with open(Workspace.make_rel_path_abs(value), "r") as f:
            if encoding is None or encoding == self._encoding or (self._encoding is None and encoding == EncodingType.string):
                string_value = f.read()
            else:
                string_value = base64.decodestring(f.read())
        return string_value

    def get_file_as_file(self, value, encoding=None):
        old_filename = Workspace.make_rel_path_abs(value)
        new_filename = Workspace.make_rel_path_abs(os.path.join(Workspace.get_log_dir(), "temp{0}_{1}.txt".format(self.__class__.__name__, self._get_random_string())))
        if encoding is None or encoding == self._encoding or (self._encoding is None and encoding == EncodingType.string):
            new_filename = old_filename
        elif encoding == EncodingType.base64 and (self._encoding == EncodingType.string or self._encoding is None):
            with open(old_filename, "r") as f:
                with open(new_filename, "w") as r:
                    r.write(base64.encodestring(f.read()))
            sleep(.2)
        else:
            with open(old_filename, "r") as f:
                with open(new_filename, "w") as r:
                    r.write(base64.decodestring(f.read()))
            sleep(.2)

        return new_filename



    def _get_random_string(self, length=5):
        return ''.join(random.choice(string.ascii_uppercase) for x in range(length))
