# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
'''
Created on May 21, 2014

@author: jenn.casler
'''
import mmap
import os

from stonesoup.metadata import SpecialOutputCheckType
from stonesoup.scoring.checks.simple.base import Base_Simple_Operation
from stonesoup.utils import Workspace
from stonesoup.metadata import EncodingType, ValueType
from stonesoup.commapi.utils import messages as message_xml, comm_enum


class Special(Base_Simple_Operation):

    def __init__(self, metadata, check):
        super(Special, self).__init__(metadata, check)
        self._logs = None

    def score(self):
            value = self._value
            if self._handling == ValueType.use_text:
                value = self.get_string_as_string(value, EncodingType.string)
            else:
                if value is not None and not os.path.isabs(value):
                    value = Workspace.make_rel_path_abs(os.path.join(self._metadata.structure.iodata, value))
                if os.path.exists(value):
                    value = self.get_file_as_string(value, EncodingType.string)

            special_type = None
            try:
                special_type = SpecialOutputCheckType[value]
            except:
                return False

            if special_type == SpecialOutputCheckType.does_not_return:
                killed = self._get_log_key('killed')
                timeout = self._get_log_key('timeout')
                return  (killed is not None and killed) or (timeout is not None and timeout)
            else:
                found = False
                message_file = self._get_log_key("messages")

                if message_file is not None and not os.path.isabs(message_file):
                    message_file = Workspace.make_rel_path_abs(message_file)

                if message_file is not None:
                    messages = message_xml.Messages.load_xml(message_file)
                    if messages is not None:
                        for message in messages.message_list:
                            if message.action is not None:
                                found = (message.action.behavior == comm_enum.ActionEnumType[special_type.value])
                            elif  message.result is not None and message.result.action is not None:
                                found = (message.result.action.behavior == comm_enum.ActionEnumType[special_type.value])


                return found


    def _get_log_key(self, key):
        if self._logs is None:
            self._logs = Workspace.get_logs()

        if self._logs.has_key('execute'):
            return self._logs['execute'][key]
        else:
            return None
