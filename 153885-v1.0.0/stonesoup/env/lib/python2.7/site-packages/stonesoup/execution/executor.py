#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

from datetime import datetime
from stonesoup.utils import texaslogging
from stonesoup.utils import cmdfile
from stonesoup.commapi import server
from stonesoup.utils import WorkspaceType, TimeoutMonitor, Workspace
from stonesoup.execution.command import execute, setup, teardown
from stonesoup.execution.control import group
from stonesoup.configuration import configuration
import os
import sys
import time
import traceback


class Executor(object):
    """
    Class that handles building a test case from source or copying contents of
    the precompiled binary directory to the install directory
    Assuming test case archive has been unpacked into workspace:

    Attributes:
        script_dir: Absolute directory to execute.sh file as str
        workspace_dir: Directory to place the log_dir folder into, path as str
        log_dir: name of log directory
        log_index_path: Name of file where log index is stored, as string
        commapi_args: Arguments to to start commsapi server, as dict
            EX: {server ip:'127.0.0.1', 'port_number':8080}
    """
    def __init__(self, **kwargs):

        """
        Constructor
        """

        Workspace.set_workspace_type(WorkspaceType.execute)

        #Initialize the logger
        texaslogging.add_logger("texas.execute")
        texaslogging.info("Started execute branch")

    def run(self, **kwargs):
        """
        Execute a test case
        Args:
            test_case_name: Name of test case from meta data as str, Ex.. J-TREE
            user: Name of user to run script under, comes from
                configuration as str
            run_dir: Relative path to execution directory, as str
            run_command: Command to be executed as str
            timeout: execution timeout as int, default is 300
            envvars: a dictionary of enviromental vars to be passed to POPEN
                {"SS_TC_DEPS":"/opt/stonesoup/deps"}
            do_nothing: Execute script but print statements
                that would be run, Boolean
            performer: Execute performer tech, Boolean
            debug: Execute in debug mode, Boolean
            verbose: Execute in verbose mode, Boolean

        Returns:
            None
        """
        comm_server = None
        try:
            texaslogging.info("Starting test case execution.")
            iopair = kwargs.pop('iopair')
            metadata = kwargs.pop('metadata')
            performer = kwargs.get('performer')

            use_global_timeout =  configuration.get_option('execute', 'global_timeout')
            global_timeout = configuration.get_option('execute', 'global_timeout_value')


            show_pbar = configuration.get_option('execute', 'progress_bar')

            options_dict = kwargs.copy()
            options_dict["iopair"] = iopair.name

            #setup environment variables
            kwargs['envvars'] = Workspace.get_envvars(metadata)
            kwargs['cwd'] = Workspace.make_rel_path_abs(metadata.structure.iodata)
            kwargs['log_dir'] = Workspace.get_log_dir()

            st_kwargs = kwargs.copy()

            #handle database
            databases = {}
            database_sections = configuration.get_option('DEFAULT', 'databases')
            for database in database_sections.split(','):
                databases[database] = configuration.get_section(database)

            kwargs['databases']  = databases

            eg_kwargs = kwargs.copy()

            #Create the run command and merge if necessary
            kwargs['run_command'] = iopair.run_command
            if iopair.run_command_merge:
                kwargs['run_command'] = '{0:s} {1:s}'.format(
                    metadata.run_command, iopair.run_command)

            #write the command file out to disk
            cmd_file_path = Workspace.make_rel_path_abs(
                configuration.get_option('execute', 'command_file'))
            texaslogging.debug("Writing execution command file.")
            cmdfile.write_command_file(path=cmd_file_path,
                                       commands={"runcommands": [
                                           kwargs['run_command']]})

            #merge ulimits
            ulimits = metadata.resource_limits
            ulimits.update(iopair.resource_limits)
            kwargs['ulimits'] = metadata.resource_limits
            kwargs['cmd_file'] = cmd_file_path
            kwargs['working_dir'] = Workspace.make_rel_path_abs(
                metadata.structure.iodata)
            #get log dictionary
            texaslogging.debug("Getting log file dictionary.")
            log_dict = Workspace.get_logs()

            #setup the CommServer
            texaslogging.debug("Starting comm server")
            comm_server = server.CommServer(**Workspace.get_commapi_args())
            comm_server.start()

            if performer:
                setup_command = setup.SetupCommand(**st_kwargs.copy())
                setup_command.start()
                setup_command.join()

            # PREPROCESS
            texaslogging.debug("Starting preprocess")
            if iopair.pre_processes is not None:
                execute_preprocess = group.ExecutionGroup(
                    stage="preprocess", execgroup=iopair.pre_processes,
                    **eg_kwargs.copy())
                execute_preprocess.start()
                execute_preprocess.join()
                log_dict.update(execute_preprocess.get_log_dict())


            timeout = iopair.timeout if (global_timeout is not None and not bool(use_global_timeout)) or performer else int(global_timeout)
            timer_fd = sys.stderr if (show_pbar in ['true', 'True', 'TRUE', '1', 'y', 'yes']) else open(os.devnull, 'w')
            monitor = TimeoutMonitor(timeout=timeout, timer_fd=timer_fd)
            # EXECUTION PROCESS
            #run the execute command
            texaslogging.debug("Starting execution command.")
            execute_command = execute.ExecuteCommand(**kwargs)
            start = time.time()
            execute_command.start()
            monitor.add_process(execute_command)
            monitor.start()

            #COPROCESS
            texaslogging.debug("Starting coprocess.")
            if iopair.co_processes is not None:
                execute_coprocess = group.ExecutionGroup(
                    stage="coprocess", execgroup=iopair.co_processes,
                    **eg_kwargs.copy())
                monitor.add_process(execute_coprocess)
                execute_coprocess.start()
                execute_coprocess.join()
                log_dict.update(execute_coprocess.get_log_dict())
            execute_command.join()
            end = time.time()
            runtime = end - start
            #stop the monitor and join to it
            monitor.stop()
            monitor.join()


            if performer:
                teardown_command = teardown.TeardownCommand(**st_kwargs.copy())
                teardown_command.start()
                teardown_command.join()

            #Stop the comm server
            texaslogging.debug("Stopping comm server.")
            comm_server.stop()

            # POSTPROCESS
            texaslogging.debug("Starting postprocess.")
            if iopair.post_processes is not None:
                execute_postprocess = group.ExecutionGroup(
                    stage="postprocess",
                    execgroup=iopair.post_processes, **eg_kwargs.copy())
                execute_postprocess.start()
                execute_postprocess.join()
                log_dict.update(execute_postprocess.get_log_dict())

            log_dict.update(execute_command.get_log_dict())
            execute_dict = log_dict[execute_command._get_process_name()]

            # Background Cleanup
            if iopair.pre_processes is not None:
                execute_preprocess.kill()
                execute_preprocess.join()
            if iopair.co_processes is not None:
                execute_coprocess.kill()
                execute_coprocess.join()
            if iopair.post_processes is not None:
                execute_postprocess.kill()
                execute_postprocess.join()

            #update execute
            execute_dict.update(options_dict)
            execute_dict["messages"] = configuration.get_option(
                'execute', 'commapi_log')
            execute_dict['run_time'] = runtime
            execute_dict['start_time'] = start
            execute_dict['end_time'] = end
            execute_dict['timeout'] = monitor.timeout_reached and execute_dict['killed']
            #update the output log info
            texaslogging.debug("Updating log file dictionary.")
            Workspace.set_logs(log_dict)

            texaslogging.info("Finished test case execution.")
            return not bool(execute_command.get_return_code())

        except:
            raise

        finally:
            #ensure that the comms server is stopped. If it is the call will simply exit.
            if comm_server is not None:
                texaslogging.debug("Stopping comms server.")
                comm_server.stop()

            texaslogging.remove_logger()

