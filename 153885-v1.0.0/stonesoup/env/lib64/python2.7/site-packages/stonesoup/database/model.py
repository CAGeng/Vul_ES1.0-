# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------


__all__ = ["DatabaseObject",
           "DbTestcase",
           "DbCodeLocation",
           "DbInjectionPoint",
           "DbComplexityFeature",
           "DbTaintSource",
           "DbDataFlow",
           "DbDataType",
           "DbControlFlow",
           "DbIoPair",
           "DbRun",
           "DbAnalyzeRun",
           "DbExecuteRun",
           "DbScoringResult",
           "DbArchive",
           "DbPerformanceResult",
           "DbQueue",
           "DbHost",
           "DbActivity"]


import collections
import os
import tempfile
import time
import uuid
from stonesoup.metadata import *
from stonesoup.database.utils import database
from bson.objectid import ObjectId
from bson.errors import InvalidId
from gridfs.grid_file import GridIn, GridOut

class DatabaseObjectError(Exception):
    pass

class DatabaseObject(object):
    def createObjectId(self):
        return ObjectId()

    @classmethod
    def collection(cls):
        raise DatabaseObjectError("Collection not available for class: {0:s}".format(cls.__name__))

    @classmethod
    def _getCollectionById(cls, id):
        _id = None
        if isinstance(id, basestring):
            try:
                _id = ObjectId(id)
            except:
                raise DatabaseObjectError("Unable to create valid object id from: {0:s}".format(id))
        elif isinstance(id, ObjectId):
            _id = id
        else:
            raise DatabaseObjectError("Invalid id of type: {0:s}".format(type(id)))

        try:
            collection = cls.collection()

            return database.find_one(collection, {"_id" : _id})
        except Exception, e:
            return None

    def save(self):
        """"Overwrites the database instance of this object.
        If the object is not in the database, it inserts this object.
        This method overwrites any currently existing instance of the object """

        dict_obj = self._dump_dict();


        return database.save(self.collection(), dict_obj)


    @classmethod
    def find(cls, object_id):
        return database.find_one(cls.collection(), object_id)


    def _parse_id(self, value):
        try:
            if value is None:
                return self.createObjectId()
            elif isinstance(value, basestring):
                return ObjectId(value)
            elif isinstance(value, ObjectId):
                return value
            else:
                raise TypeError
        except TypeError:
            raise DatabaseObjectError("Invalid type for ObjectId: {0:s}".format(value))
        except InvalidId:
            raise DatabaseObjectError("Invalid ID value for id: {0:s}".format(value))

    def _parse_id_and_object(self, name, clstype, value, obj=None):
        parsed_id = None
        parsed_obj = None
        try:
            if value is None:
                parsed_id = None
            elif isinstance(value, basestring):
                parsed_id = ObjectId(value)
            elif isinstance(value, ObjectId):
                parsed_id = value
            elif isinstance(value, clstype):
                parsed_id = value.id
            else:
                raise TypeError

            if isinstance(value, clstype):
                parsed_obj = value
            elif parsed_id is None or (obj is not None and obj.id != parsed_id):
                parsed_obj = None
            else:
                parsed_obj = obj

        except TypeError:
            raise DatabaseObjectError("Invalid type for {} id: {0:s}".format(name, type(value)))
        except InvalidId:
            raise DatabaseObjectError("Invalid ID value for {} id: {0:s}".format(name, value))

        return parsed_id, parsed_obj


class DbTestcase(DatabaseObject):
    def __init__(self,
                 _id = None,
                 name = None,
                 language = None,
                 weakness = None,
                 variant = None,
                 generation_method = None,
                 injection_point = None,
                 taint_source = None,
                 features = None,
                 binaries = None,
                 archive = None):


        self._id = self._parse_id(_id)
        self._name = name
        self._language = language
        self._binaries = []
        self._features = []
        self._weakness = weakness
        self._variant = variant
        self._injection_point = injection_point
        self._taint_source = taint_source
        self._generation_method = generation_method


        if binaries is not None and \
            isinstance(binaries, collections.Sequence):
            self._binaries.extend(binaries)


        if features is not None and \
            isinstance(features, collections.Sequence):
                for feature in features:
                    if feature is not None and \
                        not isinstance(feature, DbComplexityFeature):
                        raise DatabaseObjectError("Invalid feature type: {0:s}".format(type(feature)))

                    self._features.append(feature)


        #handle archive
        self._archive_id, self._archive = self._parse_id_and_object("archive", DbArchive, archive)

    @classmethod
    def collection(cls):
        return "testcases"

    @property
    def id(self):
        """
        Getter and setter methods for the _id of the testcase
        This will always be a bson ObjectId()
        Args:
            Value: Either a valid String or bson.ObjectId() to be used
                   as the database _id value.
        Returns:
            A valid bson.ObjectId() to be used as a database value
        """
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def name(self):
        """
        Getter and setter methods for the Testcase name
        Args:
            Value: String
        Returns:
            String name
        """
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def language(self):
        """
        Getter and setter methods for Testcase language.
        Args:
            Value: String.
        Returns:
            String language
        """
        return self._language

    @language.setter
    def language(self, value):
        self._language = value

    @property
    def weakness(self):
        """
        Getter and setter methods for Testcase weakness
        Args:
            Value: String
        Returns:
            String weakness
        """
        return self._weaknesss;

    @weakness.setter
    def weakness(self, value):
        self._weakness = value

    @property
    def variant(self):
        """
        Getter and setter methods for Testcase variant
        Args:
            Value: String
        Returns:
            String variant
        """
        return self._variant

    @variant.setter
    def variant(self, value):
        self._variant = value

    @property
    def generation_method(self):
        return self._generation_method

    @generation_method.setter
    def generation_method(self, value):
        self._generation_method = value

    @property
    def injection_point(self):
        """
        Getter and setter methods for Testcase injection point
        Args:
            Value: DbInjectionPoint
        Returns:
            DbInjectionPoint injection_point
        """
        return self._injection_point


    @injection_point.setter
    def injection_point(self, value):
        if value is not None:
            if not isinstance(value, DbInjectionPoint):
                raise DatabaseObjectError("Invalid injection point type: {0:s}".format(type(value)))
            self._injection_point = value
        else:
            self._injection_point = None


    @property
    def taint_source(self):
        """
        Getter and setter methods for Testcase taint source
        Args:
            Value: DbTaintSource
        Returns:
            DbTaintSource taint source
        """
        return self._taint_source


    @taint_source.setter
    def taint_source(self, value):
        if value is not None:
            if not isinstance(value, DbTaintSource):
                raise DatabaseObjectError("Invalid taint source type: {0:s}".format(type(value)))
            self._taint_source = value
        else:
            self._taint_source = None


    @property
    def binaries(self):
        """
        Getter and setter methods for Testcase Binaries
        This is an unordered list containing all metadata binaries.
        Args:
            Value: Single Binary or list of Binaries as strings.
        Returns:
            String list of binaries
        """
        return self._binaries


    @binaries.setter
    def binaries(self, value):
        del self._binaries[:]
        if isinstance(value, basestring):
            self._binaries.append(value)
        elif isinstance(value, collections.Sequence):
            self._binaries.extend(value)
        else:
            raise DatabaseObjectError("Invalid binaries specified")





    @property
    def features(self):
        """Getter and setter methods for Testcase Features
        An unordered list containing all other features of the testcase
        Args:
            Value: Either a Subclass of DbCodeLocation or a DbCodeLocation
        Returns:
            A list of features by ordinal beginning at 2.
        """
        return self._features


    @features.setter
    def features(self, value):
        del self._features[:]
        if value is not None:
            if isinstance(value, DbComplexityFeature):
                self._features.append(value)
            elif isinstance(value, collections.Sequence):
                for feature in value:
                    if not isinstance(feature, DbComplexityFeature):
                        raise DatabaseObjectError("Invalid feature type: {0:s}".format(type(value)))

                    self._features.append(feature)
            else:
                raise DatabaseObjectError("Invalid feature type: {0:s}".format(type(value)))




    @property
    def archive(self):
        if self._archive is None and self._archive_id is not None:
            self._archive = DbArchive.load_object(self._archive_id)
        return self._archive


    @archive.setter
    def archive(self, value):
        self._archive_id, self._archive = self._parse_id_and_object("archive", DbArchive, value, self._archive)



    def get_execute_runs(self, subquery=None):
        query =  { 'tc_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbExecuteRun.collection(), query)
        execute_runs = []
        for run in runs:
            execute_run = DbExecuteRun.load_object(run)
            execute_runs.append(execute_run)
        return execute_runs



    def get_analyze_runs(self, subquery=None):
        query =  { 'tc_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbAnalyzeRun.collection(), query)
        analyze_runs = []
        for run in runs:
            analyze_run = DbAnalyzeRun.load_object(run)
            analyze_runs.append(analyze_run)
        return analyze_runs

    def _get_features(self):
        features = list()
        for feature in self._features:
            features.append(feature.dump_dict())

        return features


    def _get_iopairs(self):
        iopair_list = list()
        if self._io_pairs is not None:
            for iopair in self._io_pairs:
                iopair_list.append(iopair.id)

            return iopair_list
        else:
            return None



    def _dump_dict(self):
        """Returns a representation of the testcase
        as it would be stored on the database.
        """
        dict_obj = dict()
        #Build straight objects into dict.
        dict_obj['_id'] = self._id
        dict_obj['name'] = self._name
        dict_obj['language'] = self._language
        dict_obj['binaries'] = self._binaries
        dict_obj['weakness'] = self._weakness
        dict_obj['variant'] = self._variant
        dict_obj['generation_method'] = self._generation_method
        dict_obj['injection_point'] = self._injection_point.dump_dict() \
                                      if self._injection_point \
                                      else None
        dict_obj['taint_source'] = self._taint_source.dump_dict() \
                                   if self._taint_source \
                                   else None
        dict_obj['archive'] = self._archive_id

        dict_obj['features'] = self._get_features()

        return dict_obj

    def dump_dict(self):
        return self._dump_dict()


    @classmethod
    def _parse_dict_feature(cls, feature):
        dict_key = 'complexity_feature' if 'complexity_feature' in feature else 'complexity_category'
        if feature[dict_key] == 'data_flow' or \
                feature[dict_key] == 'DATA_FLOW':
            return DbDataFlow.load_dict(feature)
        elif feature[dict_key] == 'data_type' or\
                feature[dict_key] == 'DATA_TYPE':
            return DbDataType.load_dict(feature)
        elif feature[dict_key] == 'control_flow' or\
                feature[dict_key] == 'CONTROL_FLOW':
            return DbControlFlow.load_dict(feature)
        else:
            raise DatabaseObjectError("Invalid feature type: {0:s}".format(feature['complexity_feature']))


    @classmethod
    def _parse_metadata_feature(cls, feature):
        if isinstance(feature, DataFlowFeature):
            return DbDataFlow.load_xml(feature)
        elif isinstance(feature, DataTypeFeature):
            return DbDataType.load_xml(feature)
        elif isinstance(feature, ControlFlowFeature):
            return DbControlFlow.load_xml(feature)
        else:
            raise DatabaseObjectError("Invalid feature type: {0:s}".format(type(feature)))


    @classmethod
    def _load_testcase_from_dict(cls, dict_obj):

        if isinstance(dict_obj, ObjectId):
            dict_obj = cls._getCollectionById(dict_obj)

        binaries = None
        features = None
        injection_point = None
        taint_source = None
        archive = None


        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        name = dict_obj['name'] if 'name' in dict_obj else None
        language = dict_obj['language'] if 'language' in dict_obj else None
        variant = dict_obj['variant'] if 'variant' in dict_obj else None
        generation_method = dict_obj['generation_method'] \
                            if 'generation_method' in dict_obj \
                            else None
        weakness = None

        #handle metadata weakness
        if 'weakness' in dict_obj:
            if isinstance(dict_obj['weakness'], basestring):
                weakness = dict_obj['weakness']
            elif isinstance(dict_obj['weakness'], dict):
                if 'variant' in dict_obj['weakness']:
                    weakness = dict_obj['weakness']['variant']['cwe']
                    variant = dict_obj['weakness']['variant']['name']
                if 'source' in dict_obj['weakness']:
                    dict_obj['taint_source'] = dict_obj['weakness']['source']
                if 'injection_point' in dict_obj['weakness']:
                    dict_obj['injection_point'] = dict_obj['weakness']['injection_point']
                if 'complexities' in dict_obj['weakness']:
                    dict_obj['features'] = dict_obj['weakness']['complexities']
                if 'generation_method' in dict_obj['weakness']:
                    generation_method = dict_obj['weakness']['generation_method']


        if 'taint_source' in dict_obj:
            taint_source = DbTaintSource.load_dict(dict_obj['taint_source'])
        #handle metadata format

        if 'injection_point' in dict_obj:
            injection_point = DbInjectionPoint.load_dict(dict_obj['injection_point'])

        if 'structure' in dict_obj:
            structure = dict_obj['structure']
            if 'binaries' in structure:
                binaries = list()
                if not isinstance(structure['binaries'], collections.Sequence):
                    raise DatabaseObjectError("Invalid binaries type: {0:s}".format(type(dict_obj['binaries'])))
                binaries.extend(structure['binaries'])

        if 'features' in dict_obj:
            features = list()
            if not isinstance(dict_obj['features'], collections.Sequence):
                raise DatabaseObjectError("Invalid features type: {0:s}".format(type(dict_obj['features'])))

            for feature in dict_obj['features']:
                features.append(cls._parse_dict_feature(feature))


        if 'archive' in dict_obj:
            archive = dict_obj['archive']

        return cls(_id=_id,
                   name=name,
                   language=language,
                   weakness=weakness,
                   variant=variant,
                   generation_method=generation_method,
                   injection_point=injection_point,
                   taint_source=taint_source,
                   binaries=binaries,
                   features=features,
                   archive=archive)


    def save(self):
        return super(DbTestcase, self).save()


    @classmethod
    def load_testcase(cls, obj):
        if obj is not None:
            if isinstance(obj, dict) or isinstance(obj, ObjectId):
                return cls._load_testcase_from_dict(obj)
            else:
                raise DatabaseObjectError("Invalid TestCase type: {0:s}".format(type(obj)))
        else:
            return None

    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update DbTestcase without id.")

        testcase = self._getCollectionById(self._id)

        if testcase is None:
            self.save()
        else:
            self._name=testcase['name']
            self._language=testcase['language']
            self._weakness=testcase['weakness']
            self._variant=testcase['variant']
            self._generation_method=testcase['generation_method']
            self._injection_point=DbInjectionPoint.load_dict(testcase['injection_point'])
            self._taint_source=DbTaintSource.load_dict(testcase['taint_source'])
            self._binaries=testcase['binaries']

            features = list()
            for feature in testcase['features']:
                features.append(self._parse_dict_feature(feature))

            self.features = features

            self._archive=testcase['archive']



class DbCodeLocation(DatabaseObject):
    def __init__(self,
                 method_name = None,
                 file_name = None,
                 line_number = None):

        self._method_name = method_name;
        self._file_name = file_name;
        self._line_number = line_number;


    @property
    def method_name(self):
        return self._method_name;


    @method_name.setter
    def method_name(self, value):
        self._method_name = value


    @property
    def file_name(self):
        return self._file_name


    @file_name.setter
    def file_name(self, value):
        self._file_name = value


    @property
    def line_number(self):
        return self._line_number


    @line_number.setter
    def line_number(self, value):
        self._line_number = value


    @classmethod
    def load_xml(cls, xml_obj):
        return cls(method_name=xml_obj.method_name,
                   file_name=xml_obj.file_name,
                   line_number=xml_obj.line_number)


    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        return cls(method_name=dict_obj['method_name'],
                   file_name=dict_obj['file_name'],
                   line_number=dict_obj['line_number'])


    def dump_dict(self):
        dict_obj = {'method_name' : self._method_name,
                    'file_name' : self._file_name,
                    'line_number' : self._line_number}

        return dict_obj


class DbInjectionPoint(DbCodeLocation):
    def __init__(self,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbInjectionPoint, self).__init__(method_name=method_name,
                                            file_name=file_name,
                                            line_number=line_number)

class DbComplexityFeature(DbCodeLocation):
    def __init__(self,
                 complexity_type = None,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbComplexityFeature, self).__init__(method_name=method_name,
                                                  file_name=file_name,
                                                  line_number=line_number)
        self._complexity_type = complexity_type


    @property
    def complexity_type(self):
        return self._complexity_type


    @complexity_type.setter
    def complexity_type(self, value):
        self._complexity_type = value


    @classmethod
    def load_xml(cls, xml_obj):
        feature = super(DbComplexityFeature, cls).load_xml(xml_obj)
        feature.complexity_type = xml_obj.complexity_type.value
        return feature


    @classmethod
    def load_dict(cls, dict_obj):

        if dict_obj is None:
            return None

        feature = super(DbComplexityFeature, cls).load_dict(dict_obj)

        feature.complexity_feature = dict_obj['complexity_feature'] \
                                     if 'complexity_feature' in dict_obj \
                                     else None
        feature.complexity_type = dict_obj['complexity_type'] \
                                  if 'complexity_type' in dict_obj \
                                  else None

        return feature


    def dump_dict(self):

        dict_obj =super(DbComplexityFeature, self).dump_dict()

        dict_obj['complexity_type'] = self._complexity_type
        return dict_obj


class DbTaintSource(DbComplexityFeature):
    def __init__(self,
                 complexity_type=None,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbTaintSource, self).__init__(complexity_type=complexity_type,
                                            method_name=method_name,
                                            file_name=file_name,
                                            line_number=line_number)

        self._complexity_feature = "taint_source"


    @property
    def complexity_feature(self):
        return self._complexity_feature


    @complexity_feature.setter
    def complexity_feature(self, value):
        self._complexity_feature = value

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        feature = super(DbTaintSource, cls).load_dict(dict_obj)

        feature.complexity_feature = 'taint_source'

        return feature

    def dump_dict(self):
        dict_obj =  super(DbTaintSource, self).dump_dict()

        dict_obj['complexity_feature'] = self._complexity_feature

        return dict_obj

class DbDataFlow(DbComplexityFeature):
    def __init__(self,
                 complexity_type = None,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbDataFlow, self).__init__(complexity_type=complexity_type,
                                         method_name=method_name,
                                         file_name=file_name,
                                         line_number=line_number)

        self._complexity_feature = 'data_flow'


    @property
    def complexity_feature(self):
        return self._complexity_feature


    @complexity_feature.setter
    def complexity_feature(self, value):
        self._complexity_feature = value

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        feature = super(DbDataFlow, cls).load_dict(dict_obj)

        feature.complexity_feature = 'data_flow'

        return feature


    @classmethod
    def load_xml(cls, xml_obj):
        feature = super(DbDataFlow, cls).load_xml(xml_obj)
        feature.complexity_feature = "data_flow"

        return feature

    def dump_dict(self):
        dict_obj =  super(DbDataFlow, self).dump_dict()

        dict_obj['complexity_feature'] = self._complexity_feature

        return dict_obj

class DbDataType(DbComplexityFeature):
    def __init__(self,
                 complexity_type = None,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbDataType, self).__init__(complexity_type=type,
                                         method_name=method_name,
                                         file_name=file_name,
                                         line_number=line_number)

        self._complexity_feature = "data_type"

    @property
    def complexity_feature(self):
        return self._complexity_feature


    @complexity_feature.setter
    def complexity_feature(self, value):
        self._complexity_feature = value

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        feature = super(DbDataType, cls).load_dict(dict_obj)

        feature.complexity_feature = 'data_type'

        return feature


    @classmethod
    def load_xml(cls, xml_obj):
        feature = super(DbDataType, cls).load_xml(xml_obj)
        feature.complexity_feature = "data_type"

        return feature

    def dump_dict(self):
        dict_obj =  super(DbDataType, self).dump_dict()

        dict_obj['complexity_feature'] = self._complexity_feature

        return dict_obj

class DbControlFlow(DbComplexityFeature):
    def __init__(self,
                 complexity_type = None,
                 method_name = None,
                 file_name = None,
                 line_number = None):
        super(DbControlFlow, self).__init__(complexity_type=type,
                                            method_name=method_name,
                                            file_name=file_name,
                                            line_number=line_number)

        self._complexity_feature = "control_flow"

    @property
    def complexity_feature(self):
        return self._complexity_feature


    @complexity_feature.setter
    def complexity_feature(self, value):
        self._complexity_feature = value

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        feature = super(DbControlFlow, cls).load_dict(dict_obj)

        feature.complexity_feature = 'control_flow'

        return feature


    @classmethod
    def load_xml(cls, xml_obj):
        feature = super(DbControlFlow, cls).load_xml(xml_obj)
        feature.complexity_feature = "control_flow"

        return feature

    def dump_dict(self):
        dict_obj =  super(DbControlFlow, self).dump_dict()
        dict_obj['complexity_feature'] = self._complexity_feature

        return dict_obj


class DbIoPair(DatabaseObject):
    def __init__(self,
                 _id = None,
                 tc_id = None,
                 name = None,
                 category = None,
                 technical_impacts = None,
                 default_scoring_formula_id = None,
                 reset = None,
                 timeout = None,
                 description = None,
                 resource_limits = None):
        self._id = self._parse_id(_id)
        self._tc_id = self._parse_tc_id(tc_id)
        self._name = name
        self._category = category
        self._technical_impacts = technical_impacts
        self._default_scoring_formula_id = default_scoring_formula_id
        self._reset = reset
        self._timeout = timeout
        self._description = description
        self._resource_limits = collections.OrderedDict()
        self._testcase = None
        if resource_limits is not None and \
           isinstance(resource_limits, collections.OrderedDict):
            for key, value in resource_limits.iteritems():
                self._resource_limits[key] = value

    @classmethod
    def collection(cls):
        return "io_pairs"
    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        self._category = value

    @property
    def technical_impacts(self):
        return self._technical_impacts

    @technical_impacts.setter
    def technical_impacts(self, value):
        self._technical_impacts = value

    @property
    def default_scoring_formula_id(self):
        return self._default_scoring_formula_id

    @default_scoring_formula_id.setter
    def default_scoring_formula_id(self, value):
        self._default_scoring_formula_id = value

    @property
    def testcase(self):
        if self._testcase is None and self._tc_id is not None:
            self._testcase = DbTestcase.load_testcase(self._tc_id)
        return self._testcase


    @testcase.setter
    def testcase(self, value):
        self._tc_id, self._testcase = self._parse_id_and_object('testcase', DbTestcase, value, self._testcase)


    @property
    def reset(self):
        return self._reset

    @reset.setter
    def reset(self, value):
        self._reset = value

    @property
    def timeout(self):
        return self._timeout

    @timeout.setter
    def timeout(self, value):
        self._timeout = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        self._description = value

    @property
    def resource_limits(self):
        return self._resource_limits

    @resource_limits.setter
    def resource_limits(self, value):
        self._resource_limits.clear()
        if value is not None:
            if not isinstance(value, collections.Mapping):
                raise DatabaseObjectError("Invalid resource limits type: {0:s}".format(type(value)))
            for type, val in value.iteritems():
                self._resource_limits[type] = val

    def get_execute_runs(self, subquery=None):
        query =  { 'io_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbExecuteRun.collection(), query)
        execute_runs = []
        for run in runs:
            execute_run = DbExecuteRun.load_object(run)
            execute_runs.append(execute_run)
        return execute_runs


    def _dump_dict(self):

        io_dict = dict()
        io_dict['_id'] = self._id
        io_dict['tc_id'] = self._tc_id
        io_dict['name'] = self._name
        io_dict['category'] = self._category
        io_dict['technical_impacts'] = self._technical_impacts
        io_dict['timeout'] = self._timeout
        io_dict['reset'] = self._reset
        io_dict['description'] = self._description
        io_dict['resource_limits'] = self._resource_limits
        io_dict['default_scoring_formula_id'] = self._default_scoring_formula_id


        return io_dict

    def dump_dict(self):
        return self._dump_dict()

    def _parse_tc_id(self, value):
        try:
            if value is not None:
                if isinstance(value, basestring):
                    return ObjectId(value)
                elif isinstance(value, ObjectId):
                    return value
                else:
                    raise TypeError
            else:
                return None
        except TypeError:
            raise DatabaseObjectError("Invalid type for testcase id: {0:s}".format(type(value)))
        except InvalidId:
            raise DatabaseObjectError("Invalid ID value for testcase id: {0:s}".format(value))

    def _parse_execute_id(self, value):
        try:
            if value is not None:
                if isinstance(value, basestring):
                    return ObjectId(value)
                elif isinstance(value, ObjectId):
                    return value
                else:
                    raise TypeError
            else:
                return None
        except TypeError:
            raise DatabaseObjectError("Invalid type for execute id: {0:s}".format(type(value)))
        except InvalidId:
            raise DatabaseObjectError("Invalid ID value for execute id: {0:s}".format(value))

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        tc_id = dict_obj['tc_id'] if 'tc_id' in dict_obj else None
        name = dict_obj['name'] if 'name' in dict_obj else None
        category = dict_obj['category'] if 'category' in dict_obj else None
        technical_impacts = dict_obj['technical_impacts'] \
                            if 'technical_impacts' in dict_obj \
                            else None

        default_scoring_formula_id = dict_obj['default_scoring_formula_id'] \
                          if 'default_scoring_formula_id' in  dict_obj \
                           else None

        reset = dict_obj['reset'] if 'reset' in dict_obj else None

        description = dict_obj['description'] \
                      if 'description' in dict_obj \
                      else None

        resource_limits = dict_obj['resource_limits'] \
                          if 'resource_limits' in dict_obj \
                          else None

        timeout = dict_obj['timeout'] \
                  if 'timeout' in dict_obj \
                  else None

        return cls(_id=_id,
                   tc_id=tc_id,
                   name=name,
                   category=category,
                   reset=reset,
                   timeout=timeout,
                   default_scoring_formula_id=default_scoring_formula_id,
                   technical_impacts=technical_impacts,
                   description=description,
                   resource_limits=resource_limits)

    @classmethod
    def load_object(cls, obj):
        if isinstance(obj, ObjectId):
            dict_obj = cls._getCollectionById(obj)
            if dict_obj is not None:
                return cls.load_dict(dict_obj)
            else:
                raise DatabaseObjectError("Unable to locate IOPair on Database.")
        elif isinstance(obj, dict):
            return cls.load_dict(obj)
        else:
            raise DatabaseObjectError("Invalid IO Pair type: {0:s}".format(type(obj)))


    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Unable to update DbIoPair without id")

        io_pair = self._getCollectionById(self._id)

        if io_pair is None:
            self.save()
        else:
            self._tc_id = io_pair['tc_id']
            self._name = io_pair['name']
            self._category = io_pair['category']
            self._reset  = io_pair['reset']
            self._timeout = io_pair['timeout']
            self._default_scoring_formula_id = io_pair['default_scoring_formula_id']
            self._technical_impacts = io_pair['technical_impacts']
            self._description = io_pair['description']
            self._resource_limits = io_pair['resource_limits']

class DbRun(DatabaseObject):
    def __init__(self,
                 _id = None,
                 queue = None,
                 testcase = None,
                 time_started = None,
                 time_ended = None,
                 hostname = None,
                 result = None,
                 error = None,
                 cwe_found=None,
                 cwes_found = None,
                 impact_found=None,
                 impacts_found = None,
                 uid = None,
                 ordinal = 0,
                 performer = False,
                 debug = False,
                 dryrun = False,
                 verbose = False,
                 release = False,
                 return_code= None,
                 archive=None):

        self._id = self._parse_id(_id)

        #handle queue
        self._queue_id, self._queue = self._parse_id_and_object('queue', DbQueue, queue)

        #handle testcase
        self._tc_id, self._testcase = self._parse_id_and_object('testcase', DbTestcase, testcase)

        #handle archive
        self._archive_id, self._archive = self._parse_id_and_object("archive", DbArchive, archive)

        self._time_started = time_started
        self._time_ended = time_ended
        self._hostname = hostname
        self._result = result
        self._error = error
        self._cwe_found = cwe_found
        self._cwes_found = []
        self._impact_found = impact_found
        self._impacts_found = []
        self._return_code = return_code
        self._performer = performer
        self._debug = debug
        self._dryrun = dryrun
        self._verbose = verbose
        self._release = release
        self.uuid = uid
        self._ordinal = int(ordinal) if ordinal is not None else None


    @property
    def id(self):
        return self._id


    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def ordinal(self):
        return self._ordinal

    @ordinal.setter
    def ordinal(self, value):
        if value is not None:
            self._ordinal = int(value)
        else:
            self._ordinal = None


    @property
    def time_started(self):
        return self._time_started


    @time_started.setter
    def time_started(self, value):
        self._time_started = value


    @property
    def time_ended(self):
        return self._time_ended


    @time_ended.setter
    def time_ended(self, value):
        self._time_ended = value


    @property
    def hostname(self):
        return self._hostname


    @hostname.setter
    def hostname(self, value):
        self._hostname = value


    @property
    def result(self):
        return self._result


    @result.setter
    def result(self, value):
        self._result = value

    @property
    def error(self):
        return self._error

    @error.setter
    def error(self, value):
        self._error = value

    @property
    def return_code(self):
        return self._return_code

    @return_code.setter
    def return_code(self, value):
        if value is not None:
            self._return_code = int(value)
        else:
            self._return_code = None

    @property
    def cwe_found(self):
        return self._cwe_found


    @cwe_found.setter
    def cwe_found(self, value):
        self._cwe_found = value

    @property
    def cwes_found(self):
        return self._cwes_found


    @cwes_found.setter
    def cwes_found(self, value):
        del self._cwes_found[:]
        if value is not None:
            if isinstance(value, basestring):
                self._cwes_found.append(value)
            elif isinstance(value, collections.Sequence):
                for cwe in value:
                    self._cwes_found.append(cwe)
            else:
                raise DatabaseObjectError("Invalid CWE's found list type: {0:s}".format(type(value)))

    @property
    def impact_found(self):
        return self._impact_found


    @impact_found.setter
    def impact_found(self, value):
        self._impact_found = value

    @property
    def impacts_found(self):
        return self._impacts_found


    @impacts_found.setter
    def impacts_found(self, value):
        del self._impacts_found[:]
        if value is not None:
            if isinstance(value, basestring):
                self._impacts_found.append(value)
            elif isinstance(value, collections.Sequence):
                for impact in value:
                    self._cwes_found.append(impact)
            else:
                raise DatabaseObjectError("Invalid CWE's found list type: {0:s}".format(type(value)))


    @property
    def queue(self):
        if self._queue is None and self._queue_id is not None:
            self._queue = DbQueue.load_object(self._queue_id)
        return self._queue



    @queue.setter
    def queue(self, value):
        self._queue_id, self._queue = self._parse_id_and_object('queue', DbQueue, value, self._queue)

    @property
    def testcase(self):
        if self._testcase is None and self._tc_id is not None:
            self._testcase = DbTestcase.load_testcase(self._tc_id)
        return self._testcase


    @testcase.setter
    def testcase(self, value):
        self._tc_id, self._testcase = self._parse_id_and_object('testcase', DbTestcase, value, self._testcase)


    @property
    def uuid(self):
        return self._uuid

    @uuid.setter
    def uuid(self, value):
        if value is not None:
            if not isinstance(value, uuid.UUID) and \
               not isinstance(value, basestring):
                raise DatabaseObjectError("Invalid UUID type: {0:s}".format(type(value)))

            if isinstance(value, uuid.UUID):
                self._uuid = value

            if isinstance(value, basestring):
                try:
                    self._uuid = uuid.UUID(value)
                except:
                    raise DatabaseObjectError("Unable to create uuid from: {0:s}".format(value))
        else:
            self._uuid = None


    @property
    def performer(self):
        return self._performer

    @performer.setter
    def performer(self, value):
        self._performer = bool(value)

    @property
    def debug(self):
        return self._debug

    @debug.setter
    def debug(self, value):
        self._debug = bool(value)

    @property
    def dryrun(self):
        return self._dryrun

    @dryrun.setter
    def dryrun(self, value):
        self._dryrun = bool(value)

    @property
    def verbose(self):
        return self._verbose

    @verbose.setter
    def verbose(self, value):
        self._verbose = bool(value)

    @property
    def release(self):
        return self._release

    @release.setter
    def release(self, value):
        self._release = bool(value)


    @property
    def archive(self):
        if self._archive is None and self._archive_id is not None:
            self._archive = DbArchive.load_object(self._archive_id)
        return self._archive


    @archive.setter
    def archive(self, value):
        self._archive_id, self._archive = self._parse_id_and_object("archive", DbArchive, value, self._archive)


    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None
        archive = None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        queue = dict_obj['queue_id'] if 'queue_id' in dict_obj else None
        testcase = dict_obj['tc_id'] if 'tc_id' in dict_obj else None
        time_started = dict_obj['time_started'] \
                       if 'time_started' in dict_obj \
                       else None
        time_ended = dict_obj['time_ended'] \
                       if 'time_ended' in dict_obj \
                       else None

        uid = dict_obj['uuid'] if 'uuid' in dict_obj else None

        performer = dict_obj['performer'] if 'performer' in dict_obj else None
        debug = dict_obj['debug'] if 'debug' in dict_obj else None
        dryrun = dict_obj['dryrun'] if 'dryrun' in dict_obj else None
        verbose = dict_obj['verbose'] if 'verbose' in dict_obj else None
        release = dict_obj['release'] if 'release' in dict_obj else None
        return_code = dict_obj['return_code'] \
                      if 'return_code' in dict_obj \
                      else None
        hostname = dict_obj['hostname'] if 'hostname' in dict_obj else None

        cwe_found = dict_obj['cwe_found'] \
                     if 'cwe_found' in dict_obj\
                     else None

        cwes_found = dict_obj['cwes_found'] \
                     if 'cwes_found' in dict_obj\
                     else None

        impact_found = dict_obj['impact_found'] \
                     if 'impact_found' in dict_obj\
                     else None

        impacts_found = dict_obj['impacts_found'] \
                     if 'impacts_found' in dict_obj\
                     else None

        result = dict_obj['result'] if 'result' in dict_obj else None
        error  = dict_obj['error'] if 'error' in dict_obj else None
        ordinal = dict_obj['ordinal'] if 'ordinal' in dict_obj else None

        if 'archive_id' in dict_obj:
            archive = dict_obj['archive_id']

        return cls(_id=_id,
                   queue=queue,
                   testcase=testcase,
                   time_started=time_started,
                   time_ended=time_ended,
                   hostname=hostname,
                   cwe_found=cwe_found,
                   cwes_found=cwes_found,
                   impact_found=impact_found,
                   impacts_found=impacts_found,
                   uid=uid,
                   ordinal=ordinal,
                   result=result,
                   error=error,
                   performer=performer,
                   debug=debug,
                   dryrun=dryrun,
                   verbose=verbose,
                   release=release,
                   return_code=return_code,
                   archive=archive)


    def load_xml(self):
        raise DatabaseObjectError("Cannot directly load xml into DbRun class.\n\
                                  No such metadata exists for a testcase run.")


    def _dump_dict(self):
        run_obj = dict()
        run_obj['_id'] = self._id
        run_obj['tc_id'] = self._tc_id
        run_obj['time_started'] = self._time_started
        run_obj['time_ended'] = self._time_ended
        run_obj['hostname'] = self._hostname
        run_obj['cwe_found'] = self._cwe_found
        run_obj['cwes_found'] = self._cwes_found
        run_obj['impact_found'] = self._impact_found
        run_obj['impacts_found'] = self._impacts_found
        run_obj['result'] = self._result
        run_obj['error'] = self._error
        run_obj['uuid'] = str(self._uuid.hex)\
                          if self._uuid is not None \
                          else None
        run_obj['archive_id']  = self._archive_id
        run_obj['performer'] = self._performer
        run_obj['debug']= self._debug
        run_obj['dryrun'] = self._dryrun
        run_obj['verbose'] = self._verbose
        run_obj['release'] = self._release
        run_obj['return_code'] = self._return_code
        run_obj['ordinal'] = self._ordinal
        run_obj['queue_id'] = self._queue_id
        return run_obj


    def dump_dict(self):
        return self._dump_dict()


    def save(self):
        run_dict = self._dump_dict()

        return database.save(self.collection(), run_dict)


    def _update_values(self, run):

        if 'uuid' in run and run['uuid'] is not None:
            self._uuid = uuid.UUID(run['uuid'])
        else:
            self._uuid = None

        if 'tc_id' in run and run['tc_id'] is not None:
            self._tc_id = ObjectId(run['tc_id'])
            if self._testcase is not None and self._testcase.id != self._tc_id:
                self._testcase = None
        else:
            self._tc_id = None
            self._testcase = None

        if 'archive_id' in run and run['archive_id'] is not None:
            self._archive_id = ObjectId(run['archive_id'])
            if self._archive is not None and self._archive.id != self._archive_id:
                self._archive = None
        else:
            self._archive_id = None
            self._archive = None

        self._time_started = run['time_started']
        self._time_ended = run['time_ended']
        self._hostname = run['hostname']
        self._cwe_found = run['cwe_found']
        self._cwes_found = run['cwes_found']
        self._impact_found = run['impact_found']
        self._impacts_found = run['impacts_found']
        self._result = run['result']
        self._error = run['error']
        self._ordinal = run['ordinal']
        self._performer = run['performer']
        self._debug = run['debug']
        self._dryrun = run['dryrun']
        self._verbose = run['verbose']
        self._release = run['release']
        self._return_code = run['return_code']

    def update(self):
        raise DatabaseObjectError("Cannot update a DbRun directly.")


class DbAnalyzeRun(DbRun):
    def __init__(self,
                 _id = None,
                 queue = None,
                 testcase = None,
                 time_started = None,
                 time_ended = None,
                 hostname = None,
                 result = None,
                 error = None,
                 cwe_found=None,
                 cwes_found = None,
                 impact_found=None,
                 impacts_found = None,
                 uid = None,
                 ordinal = 0,
                 skip = None,
                 return_code = None,
                 performer = False,
                 debug = False,
                 dryrun = False,
                 verbose = False,
                 release = False,
                 archive = None):
        super(DbAnalyzeRun, self).__init__(_id=_id,
                                           queue=queue,
                                           testcase = testcase,
                                           time_started=time_started,
                                           time_ended=time_ended,
                                           hostname=hostname,
                                           result=result,
                                           error=error,
                                           cwe_found=cwe_found,
                                           cwes_found=cwes_found,
                                           impact_found=impact_found,
                                           impacts_found=impacts_found,
                                           uid=uid,
                                           ordinal=ordinal,
                                           performer=performer,
                                           debug=debug,
                                           dryrun=dryrun,
                                           verbose=verbose,
                                           release=release,
                                           return_code=return_code,
                                           archive=archive)
        self._skip = skip


    @classmethod
    def collection(cls):
        return "analyze_runs"

    @property
    def skip(self):
        return self._skip

    @skip.setter
    def skip(self, value):
        self._skip = bool(value)

    def get_execute_runs(self, subquery=None):
        query =  { 'analyze_run_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbExecuteRun.collection(), query)
        execute_runs = []
        for run in runs:
            execute_run = DbExecuteRun.load_object(run)
            execute_runs.append(execute_run)
        return execute_runs


    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        analyze_run = super(DbAnalyzeRun, cls).load_dict(dict_obj)

        analyze_run.skip = dict_obj['skip'] if 'skip' in dict_obj else None


        return analyze_run




    @classmethod
    def load_object(cls, object_id):
        if object_id is None:
            return None
        elif isinstance(object_id, dict):
            return cls.load_dict(object_id)
        elif isinstance(object_id, ObjectId):
            return cls.load_dict(cls.find(object_id))
        else:
            raise DatabaseObjectError("Invalid object type: {0:s}".format(type(object_id)))


    def _dump_dict(self):
        analyze_obj = super(DbAnalyzeRun, self)._dump_dict()

        analyze_obj['skip'] = self._skip

        return analyze_obj


    def dump_dict(self):
        return self._dump_dict()

    def save(self):
        return super(DbAnalyzeRun, self).save()
    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update execute run without id.")

        run = self._getCollectionById(self._id)

        if run is None:
            #if it doesn't exist save it to the database!
            self.save()
        else:
            super(DbAnalyzeRun, self)._update_values(run)

            self._skip = run['skip'] if 'skip' in run else None


class DbExecuteRun(DbRun):
    def __init__(self,
                 _id = None,
                 queue = None,
                 testcase = None,
                 iopair = None,
                 time_started = None,
                 time_ended = None,
                 hostname = None,
                 result = None,
                 error=None,
                 cwe_found=None,
                 cwes_found = None,
                 impact_found=None,
                 impacts_found = None,
                 uid = None,
                 ordinal= 0,
                 analyze_run=None,
                 return_code = None,
                 timeout=None,
                 performer = False,
                 debug = False,
                 dryrun = False,
                 verbose = False,
                 release = False,
                 archive = None):
        super(DbExecuteRun, self).__init__(_id=_id,
                                           queue = queue,
                                           testcase = testcase,
                                           time_started=time_started,
                                           time_ended=time_ended,
                                           hostname=hostname,
                                           result=result,
                                           error=error,
                                           cwe_found=cwe_found,
                                           cwes_found=cwes_found,
                                           impact_found=impact_found,
                                           impacts_found=impacts_found,
                                           uid=uid,
                                           ordinal=ordinal,
                                           performer=performer,
                                           debug=debug,
                                           dryrun=dryrun,
                                           verbose=verbose,
                                           release=release,
                                           return_code=return_code,
                                           archive=archive)



        self._analyze_run_id, self._analyze_run = self._parse_id_and_object('analyze_run', DbAnalyzeRun, analyze_run)
        self._io_id, self._iopair = self._parse_id_and_object("iopair", DbIoPair, iopair)
        self._timeout = timeout


    @classmethod
    def collection(cls):
        return "execute_runs"


    @property
    def iopair(self):
        if self._iopair is None and self._io_id is not None:
            self._iopair = DbIoPair.load_object(self._io_id)
        return self._iopair

    @iopair.setter
    def iopair(self, value):
        self._io_id, self._iopair = self._parse_id_and_object("iopair", DbIoPair, value, self._iopair)

    @property
    def analyze_run(self):
        if self._analyze_run is None and self._analyze_run_id is not None:
            self._analyze_run =  DbAnalyzeRun.load_object(self._analyze_run_id)
        return self._analyze_run

    @analyze_run.setter
    def analyze_run(self, value):
        self._analyze_run_id, self._analyze_run = self._parse_id_and_object('analyze_run', DbAnalyzeRun, value, self._analyze_run)

    @property
    def timeout(self):
        return self._timeout

    @timeout.setter
    def timeout(self, value):
        self._timeout = value

    def get_scoring_results(self, subquery=None):
        query =  { 'execute_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        results = database.find(DbScoringResult.collection(), query)
        scoring_results = []
        for result in results:
            score_result = DbScoringResult.load_object(result)
            scoring_results.append(score_result)
        return scoring_results


    def get_performance_results(self, subquery=None):
        query =  { 'execute_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        results = database.find(DbPerformanceResult.collection(), query)
        scoring_results = []
        for result in results:
            score_result = DbPerformanceResult.load_object(result)
            scoring_results.append(score_result)
        return scoring_results

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None
        execute_run = super(DbExecuteRun, cls).load_dict(dict_obj)

        execute_run.analyze_run = dict_obj['analyze_run_id'] \
                                  if 'analyze_run_id' in dict_obj \
                                  else None

        execute_run.iopair = dict_obj['io_id'] if 'io_id' in dict_obj else None

        execute_run.timeout = dict_obj['timeout'] if 'timeout' in dict_obj else None

        return execute_run


    @classmethod
    def load_object(cls, object_id):
        if object_id is None:
            return None
        elif isinstance(object_id, dict):
            return cls.load_dict(object_id)
        elif isinstance(object_id, ObjectId):
            return cls.load_dict(cls.find(object_id))
        else:
            raise DatabaseObjectError("Invalid object type: {0:s}".format(type(object_id)))


    def _dump_dict(self):
        execute_obj = super(DbExecuteRun, self)._dump_dict()

        execute_obj['io_id'] = self._io_id
        execute_obj['analyze_run_id'] = self._analyze_run_id
        execute_obj['timeout'] = self._timeout
        return execute_obj


    def dump_dict(self):
        return self._dump_dict()


    def save(self):

        return super(DbExecuteRun, self).save()


    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update execute run without id.")

        run = self._getCollectionById(self._id)

        if run is None:
            #if it doesn't exist save it!
            self.save()
        else:
            super(DbExecuteRun, self)._update_values(run)

            if 'io_id' in run and run['io_id'] is not None:
                self._io_id = ObjectId(run['io_id'])
                if self._iopair is not None and self._iopair.id != self._io_id:
                    self._archive = None
            else:
                self._io_id = None
                self._iopair = None

            if 'analyze_run' in run and run['analyze_run'] is not None:
                self._analyze_run_id = ObjectId(run['analyze_run'])
                if self._analyze_run is not None and self._analyze_run.id != self._analyze_run_id:
                    self._analyze_run = None
            else:
                self._analyze_run_id = None
                self._analyze_run = None

            self._timeout = run['timeout'] if 'timeout' in run else None


class DbScoringResult(DatabaseObject):
    def __init__(self,
                 _id = None,
                 execute_run = None,
                 name = None,
                 value = None,
                 score_type = None,
                 result = None,
                 error = None):
        self._id = self._parse_id(_id)
        self._execute_id, self._execute_run = self._parse_id_and_object("execute_run", DbExecuteRun, execute_run)
        self._name = name
        self._value = value
        self._score_type = score_type
        self._result = result
        self._error = error

    @classmethod
    def collection(cls):
        return "scoring_results"


    @property
    def id(self):
        return self._id


    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)


    @property
    def execute_run(self):
        if self._execute_run is None and self._execute_id is not None:
            self._execute_run = DbExecuteRun.load_object(self._execute_id)
        return self._execute_run


    @execute_run.setter
    def execute_run(self, value):
        self._execute_id, self._execute_run = self._parse_id_and_object("execute_run", DbExecuteRun, value, self._execute_run)


    @property
    def name(self):
        return self._name


    @name.setter
    def name(self, value):
        self._name = value


    @property
    def score_type(self):
        return self._score_type


    @score_type.setter
    def score_type(self, value):
        self._score_type = value


    @property
    def value(self):
        return self._value


    @value.setter
    def value(self, value):
        self._value = value


    @property
    def result(self):
        return self._result


    @result.setter
    def result(self, value):
        self._result = value


    @property
    def error(self):
        return self._error

    @error.setter
    def error(self, value):
        self._error = value

    def _parse_execute_id(self, value):
            try:
                if value is not None:
                    if isinstance(value, basestring):
                        return ObjectId(value)
                    elif isinstance(value, ObjectId):
                        return value
                    else:
                        raise TypeError
                else:
                    return None
            except TypeError:
                raise DatabaseObjectError("Invalid type for execute run id: {0:s}".format(type(value)))
            except InvalidId:
                raise DatabaseObjectError("Invalid ID value for excute run id: {0:s}".format(value))

    @classmethod
    def load_dict(cls, dict_obj):

        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        execute_id = dict_obj['execute_id'] \
                     if 'execute_id' in dict_obj \
                     else None
        name = dict_obj['name'] if 'name' in dict_obj else None
        value = dict_obj['value'] if 'value' in dict_obj else None
        score_type = dict_obj['score_type'] if 'score_type' in dict_obj else None
        result = dict_obj['result'] if 'result' in dict_obj else None
        error = dict_obj['error'] if 'error' in dict_obj else None

        return cls(_id=_id,
                   execute_run=execute_id,
                   name=name,
                   value=value,
                   score_type=score_type,
                   result=result,
                   error=error)

    @classmethod
    def load_object(cls, object_id):
        if object_id is None:
            return None
        elif isinstance(object_id, ObjectId):
            return cls.load_dict(cls.find(object_id))
        elif isinstance(object_id, dict):
            return cls.load_dict(object_id)
        else:
            raise DatabaseObjectError("Invalid Scoring Component type: {0:s}".format(type(object_id)))


    def load_xml(self):
        raise DatabaseObjectError("Cannot directly load xml into DbScoringResult class.\n\
                                  No such metadata exists for a testcase run.")


    def _dump_dict(self):
        score_obj = dict()

        score_obj['_id'] = self._id
        score_obj['execute_id'] = self._execute_id
        score_obj['name'] = self._name
        score_obj['value'] = self._value
        score_obj['score_type'] = self._score_type
        score_obj['result'] = self._result
        score_obj['error'] = self._error
        return score_obj


    def dump_dict(self):
        return self._dump_dict()


    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update Scoring Result without ID")

        result = self._getCollectionById(self._id)

        if result is None:
            self.save()
        else:

            if 'execute_id' in result and result['execute_id'] is not None:
                self._execute_id = ObjectId(result['execute_id'])
                if self._execute_run is not None and self._execute_run.id != self._execute_id:
                    self._execute_run = None
            else:
                self._execute_id = None
                self._execute_run = None

            self._name = result['name']
            self._value = result['value']
            self._score_type = result['score_type']
            self._error= result['error']
            self._result = result['result']


class DbArchive(DatabaseObject):
    def __init__(self,
                 _id = None,
                 file_location = None,
                 filename = None,
                 md5_hash = None,
                 gridFS = None):
        self._id = self._parse_id(_id)
        self._filename = filename
        self._md5_hash = md5_hash
        self._gridFS = self._parse_gridFS(gridFS)
        self._file_location = file_location

    @classmethod
    def collection(cls):
        return "archive"

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def filename(self):
        return self._filename

    @filename.setter
    def filename(self, value):
        self._filename = value

    @property
    def file_location(self):
        return self._file_location

    @file_location.setter
    def file_location(self, value):
        self._file_location = value

    @property
    def md5_hash(self):
        return self._md5_hash

    @md5_hash.setter
    def md5_hash(self, value):
        self._md5_hash = value

    @property
    def gridFS(self):
        return self._gridFS

    @gridFS.setter
    def gridFS(self, value):
        self._gridFS = self._parseGridFS(value)


    def get_archive(self):
        """Gets an archive from the mongo server and saves it to a temp folder.
            Args:
                None
            Returns:
                An absolute path to the newly saved archive.
        """

        if self._gridFS is None:
            raise DatabaseObjectError("Must create or initialize an archive.")
        prefix = self._filename.split('.')[0] + "_" \
                 if self._filename is not None \
                 else "ARCHIVE_"
        self._gridFS.seek(0)
        temp_archive = tempfile.NamedTemporaryFile(suffix=".tar.gz",
                                                     prefix=prefix,
                                                     delete=False)
        self._file_location = temp_archive.name

        size=self._gridFS.length
        received = 0
        while received < size:
            chunk_data = self._gridFS.readchunk()
            received += len(chunk_data)
            temp_archive.write(chunk_data)

        temp_archive.close()


        return self._file_location


    @classmethod
    def create(cls, archive=None,_id=None):
        """ Creates a database archive object from a given archive filename
            Args:
                Archive - String filename containing the location of the
                          archive on the local system.
            Returns:
                An instance of DbArchive
        """
        if archive is None:
            raise DatabaseObjectError("Archive name cannot be none.")

        elif not isinstance(archive, basestring):
            raise DatabaseObjectError("Archive must be a file name.")

        elif not os.path.exists(archive):
            raise DatabaseObjectError("Invalid pathname: {0:s}".format(archive))


        if _id is None:
            _id = ObjectId()

        grid_id = database.upload_file(collection=cls.collection(),
                                       filename=archive,
                                       _id=_id)
        grid_file = database.find_file(cls.collection(), grid_id)

        return cls(_id=grid_file._id,
                   file_location = archive,
                   filename=grid_file.filename,
                   md5_hash=grid_file.md5,
                   gridFS=grid_file)


    def update(self, archive=None):
        """Updates a archive object with a new archive. Requires the
           archive file path again, to ensure that the archive exists.
           Args:
               Archive - String filename containing the location of the archive
               on the system.
            Returns:
                id of the archive
            Special Considerations -
                - If the archive name is different we cannot update the archive.
        """

        if archive is not None:
            base_name = os.path.basename(archive)
        else:
            if os.path.exists(self._file_location):
                archive = self._file_location
                base_name = self._filename
            else:
                raise DatabaseObjectError("Cannot update archive with non-existent file")


        if self._filename is not None and self._filename != base_name:
            raise DatabaseObjectError("Cannot update archives with different names")

        grid_id = database.upload_file(self.collection(), archive)
        grid_file = database.find_file(self.collection(), grid_id)

        self._id = grid_file._id
        self._file_location = archive \
                              if archive is not None \
                              else self._file_location
        self._gridFS = grid_file
        self._md5_hash = grid_file.md5

        return self._id


    def delete(self):
        """Attempts to delete an archive from the system using the database.
           Args:
               None
           Returns:
               None
           Special Notes:
               - If the database has not been created the method will throw an
                 error.
        """
        if self._id is None:
            raise DatabaseObjectError("Unable to delete object without an id.")
        else:
            database.remove_file(self.collection(), self._id)
            self._gridFS = None
            self._file_location = None
            self._md5_hash = None


    def save(self):
        if self._file_location is None:
            raise DatabaseObjectError("Cannot save without specified archive.")

        if database.file_exists(self.collection(), self._id):
            database.remove_file(self.collection(), self._id)

        archive = self.create(self._file_location, self._id)

        return self._id


    def _parse_gridFS(self, gridFS):
        if gridFS is None:
            return None
        elif isinstance(gridFS, GridOut):
            return gridFS
        elif isinstance(gridFS, ObjectId):
            return database.find_file(self.collection(), gridFS)
        else:
            raise DatabaseObjectError("Invalid type for gridFS object: {0:s}".format(type(gridFS)))


    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        filename = dict_obj['filename'] if 'filename' in dict_obj else None
        md5_hash = dict_obj['md5_hash'] if 'md5_hash' in dict_obj else None
        gridFS = None
        if _id is not None:
            gridFS = database.find_file(cls.collection(), _id)

        #we ignore file_location here as any time we're loading a DbArchive
        #dict we want to allow for the developer to create the
        #file on the fly as opposed to having a pre-determined position
        return cls(_id=_id,
                   filename=filename,
                   md5_hash=md5_hash,
                   gridFS=gridFS)


    @classmethod
    def _load_object(cls, obj):
        database_object = database.find_file(cls.collection(), obj)

        if database_object is None:
            return None

        return cls(_id = database_object._id,
                   filename=database_object.filename,
                   md5_hash=database_object.md5,
                   gridFS=database_object)


    @classmethod
    def load_object(cls, archive_object=None):
        if archive_object is None:
            return None
        elif isinstance(archive_object, dict):
            return cls.load_dict(archive_object)
        elif isinstance(archive_object, ObjectId):
            return cls._load_object(archive_object)
        else:
            raise DatabaseObjectError("Invalid archive type: {0:s}".format(type(archive_object)))


    @classmethod
    def load_archive(cls, archive=None):
        """Create a DbArchive object out of a tarball link."""
        filename = None
        md5_hash = None
        gridFS = None
        file_location = None
        if archive is None:
            return None
        elif isinstance(archive, basestring):
            if os.path.exists(archive):
                file_location = archive
                filename = os.path.basename(file_location)
            else:
                raise DatabaseObjectError("Can only specify existing tarball.")
        else:
            return cls.load_object(archive)

        return cls(filename=filename,
                   md5_hash=md5_hash,
                   gridFS=gridFS,
                   file_location=file_location)



class DbPerformanceResult(DatabaseObject):
    def __init__(self,
                 _id = None,
                 execute_run = None,
                 name = None,
                 ordinal = None,
                 point_type = None,
                 time_stamp = None,
                 delta = None):
        self._id = self._parse_id(_id)
        self._execute_id, self._execute_run = self._parse_id_and_object("execute_run", DbExecuteRun, execute_run)
        self._name = name
        self._ordinal = ordinal
        self._point_type = point_type
        self._time_stamp = time_stamp
        self._delta = delta

    @classmethod
    def collection(cls):
        return "performance_results"


    @property
    def id(self):
        return self._id


    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)


    @property
    def execute_run(self):
        if self._execute_run is None and self._execute_id is not None:
            self._execute_run = DbExecuteRun.load_object(self._execute_id)
        return self._execute_run


    @execute_run.setter
    def execute_run(self, value):
        self._execute_id, self._execute_run = self._parse_id_and_object("execute_run", DbExecuteRun, value, self._execute_run)

    @property
    def name(self):
        return self._name


    @name.setter
    def name(self, value):
        self._name = value


    @property
    def point_type(self):
        return self._point_type


    @point_type.setter
    def point_type(self, value):
        self._point_type = value


    @property
    def ordinal(self):
        return self._ordinal

    @ordinal.setter
    def ordinal(self, value):
        if value is not None:
            self._ordinal = int(value)
        else:
            self._ordinal = None


    @property
    def time_stamp(self):
        return self._time_stamp


    @time_stamp.setter
    def time_stamp(self, value):
        self._time_stamp = value


    @property
    def delta(self):
        return self._delta

    @delta.setter
    def delta(self, value):
        self._delta = value

    def _parse_execute_id(self, value):
            try:
                if value is not None:
                    if isinstance(value, basestring):
                        return ObjectId(value)
                    elif isinstance(value, ObjectId):
                        return value
                    else:
                        raise TypeError
                else:
                    return None
            except TypeError:
                raise DatabaseObjectError("Invalid type for execute run id: {0:s}".format(type(value)))
            except InvalidId:
                raise DatabaseObjectError("Invalid ID value for excute run id: {0:s}".format(value))

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        execute_id = dict_obj['execute_id'] \
                     if 'execute_id' in dict_obj \
                     else None
        name = dict_obj['name'] if 'name' in dict_obj else None
        ordinal = dict_obj['ordinal'] if 'ordinal' in dict_obj else None
        point_type = dict_obj['point_type'] if 'point_type' in dict_obj else None
        time_stamp = dict_obj['time_stamp'] if 'time_stamp' in dict_obj else None
        delta = dict_obj['delta'] if 'delta' in dict_obj else None

        return cls(_id=_id,
                   execute_run=execute_id,
                   name=name,
                   ordinal=ordinal,
                   point_type=point_type,
                   time_stamp=time_stamp,
                   delta=delta)

    @classmethod
    def load_object(cls, object_id):
        if object_id is None:
            return None
        elif isinstance(object_id, ObjectId):
            return cls.load_dict(cls.find(object_id))
        elif isinstance(object_id, dict):
            return cls.load_dict(object_id)
        else:
            raise DatabaseObjectError("Invalid Performance Result type: {0:s}".format(type(object_id)))

    def load_xml(self):
        raise DatabaseObjectError("Cannot directly load xml into DbPerformanceResult class.\n\
                                  No such metadata exists for a testcase run.")


    def _dump_dict(self):
        score_obj = dict()

        score_obj['_id'] = self._id
        score_obj['execute_id'] = self._execute_id
        score_obj['name'] = self._name
        score_obj['ordinal'] = self._ordinal
        score_obj['point_type'] = self._point_type
        score_obj['time_stamp'] = self._time_stamp
        score_obj['delta'] = self._delta
        return score_obj


    def dump_dict(self):
        return self._dump_dict()


    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update Scoring Component without ID")

        result = self._getCollectionById(self._id)

        if result is None:
            self.save()
        else:
            if 'execute_id' in result and result['execute_id'] is not None:
                self._execute_id = ObjectId(result['execute_id'])
                if self._execute_run is not None and self._execute_run.id != self._execute_id:
                    self._execute_run = None
            else:
                self._execute_id = None
                self._execute_run = None

            self._name = result['name']
            self._ordinal = result['ordinal']
            self._point_type = result['point_type']
            self._time_stamp= result['time_stamp']
            self._delta = result['delta']

class DbQueue(DatabaseObject):
    def __init__(self,
                 _id = None,
                 active = False,
                 queue_name = None):

        self._id = self._parse_id(_id)
        self._active = bool(active)
        self._queue_name = queue_name
        self._uuid = self._generate_uuid()

    @classmethod
    def collection(cls):
        return "queues"

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def active(self):
        return self._active

    @active.setter
    def active(self, value):
        self._active = bool(value)

    @property
    def queue_name(self):
        return self._queue_name

    @queue_name.setter
    def queue_name(self, value):
        self._queue_name = value


    def get_execute_runs(self, subquery=None):
        query =  { 'queue_id' : self._id }
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbExecuteRun.collection(), query)
        execute_runs = []
        for run in runs:
            execute_run = DbExecuteRun.load_object(run)
            execute_runs.append(execute_run)
        return execute_runs

    def get_analyze_runs(self, subquery=None):
        query= {'queue_id' : self._id}
        if subquery is not None:
            query.update(subquery)
        runs = database.find(DbAnalyzeRun.collection(), query)
        analyze_runs = []
        for run in runs:
            analyze_run = DbAnalyzeRun.load_object(run)
            analyze_runs.append(analyze_run)
        return analyze_runs


    def _dump_dict(self):
        queue_obj = dict()
        queue_obj['_id'] = self._id
        queue_obj['active'] = self._active
        queue_obj['queue_name'] = self._queue_name
        return queue_obj


    def dump_dict(self):
        return self._dump_dict()

    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        queue_name = dict_obj['queue_name'] \
                     if 'queue_name' in dict_obj \
                     else None
        active = dict_obj['active'] if 'active' in dict_obj else None
        return cls(_id=_id,
                   active=active,
                   queue_name=queue_name)


    @classmethod
    def load_object(cls, queue_obj=None):
        if queue_obj is None:
            return None
        elif isinstance(queue_obj, dict):
            return cls.load_dict(queue_obj)
        elif isinstance(queue_obj, ObjectId):
            return cls.load_dict(cls.find(queue_obj))
        else:
            raise DatabaseObjectError("Invalid queue type: {0:s}".format(type(queue_obj)))


    @classmethod
    def get_queue(cls, queue_name=None):

        if queue_name is None:
            return None

        elif isinstance(queue_name, basestring):
            queue = database.find_one(cls.collection(),
                                      {"queue_name" : queue_name})

            if queue is None:
                return None
            return cls.load_object(queue)


    def update(self):
        if self._id is None:
            raise DatabaseObjectError("Cannot update Queue without ID")

        queue = self._getCollectionById(self._id)

        if queue is None:
            self.save()
        else:
            #update the queue with new objects
            self._active = queue['active']
            self._queue_name = queue['queue_name']

    def save(self):
        return super(DbQueue, self).save()


    def get_analyze_job(self):
        self.update()
        if not self._active:
            return None

        if self._uuid is None:
            raise DatabaseObjectError("Cannot pull run without Universally Unique Identifier.")
        database_query = {'uuid' : None, 'result' : None,
                          'queue_id' : self._id}
        sort_key = 'ordinal'

#         run = database.sorted_find_one(DbAnalyzeRun.collection(), database_query, sort_key)
        run = database.find_and_modify(DbAnalyzeRun.collection(), #the collection
                                       database_query, #the object we're updating
                                       {'uuid' : self._uuid.hex, 'time_started' : time.time(), 'hostname' : self._get_hostname()}, #the values to change
                                       upsert=False, sort=sort_key,  #don't insert if nonexistent and ascending sort on ordinal.
                                       new=True) #return the new one
        analyze_run = DbAnalyzeRun.load_object(run)
        return analyze_run


    def get_execute_job(self):
        self.update()

        if not self._active:
            return None

        if self._uuid is None:
            raise DatabaseObjectError("Cannot pull run without Universally Unique Identifier.")
        #execute_runs = sorted(self._execute_runs, key=lambda x: x.ordinal)
        analyze_runs_list = database.find(DbAnalyzeRun.collection(), { 'queue_id' : self._id, 'result' : { '$ne' : None }})
        analyze_run_ids = analyze_runs_list.distinct("_id")
        database_query = {'uuid' : None, 'result' : None,
                          'queue_id' : self._id, 'analyze_run_id': { '$in' : analyze_run_ids }}
        sort_key = 'ordinal'

#         successful_analyze_runs = database.find(collection=DbAnalyzeRun.collection(), # the collection to look from
#                                                 query={'result' : True, 'queue_id' : self._id}, #The query to check on
#                                                 fields='_id')
#
# #         run = database.sorted_find_one(DbExecuteRun.collection(), database_query, sort_key)
#         analyze_runs = []
#         for run in successful_analyze_runs:
#             analyze_runs.append(run['_id'])
#
#         database_query.update({'analyze_runs' : {'$in' : analyze_runs}})

        run = database.find_and_modify(DbExecuteRun.collection(), #the collection
                                       database_query, #the object we're updating
                                       {'uuid' : self._uuid.hex, 'time_started' : time.time(), 'hostname' : self._get_hostname()}, #the values to change
                                       upsert=False, sort=sort_key, #don't insert if nonexistent and ascending sort on ordinal.
                                       new=True) #return the new one



        execute_run = DbExecuteRun.load_object(run)



        if execute_run is None:
            return

        analyze_run = execute_run.analyze_run

        if analyze_run is None or analyze_run.result is None:
            execute_run.uuid = None
            execute_run.time_started = None
            execute_run.hostname = None
            execute_run.save()
            return
        elif analyze_run.skip or (analyze_run.result is not None and analyze_run.result is not True ):
            execute_run.result = 'skip'
            execute_run.time_started = analyze_run.time_started
            execute_run.time_ended = analyze_run.time_ended
            execute_run.save()
            return


        return execute_run



    def _generate_uuid(self):
        return uuid.uuid4()


    def _get_hostname(self):
        import socket
        name = None
        if socket.gethostname().find('.')<=0:
            name=socket.gethostname()
        else:
            name=socket.gethostbyaddr(socket.gethostname())[0]
        return name

class DbHost(DatabaseObject):
    def __init__(self,
                 _id=None,
                 name=None,
                 current=None,
                 previous=None,
                 active = True,
                 job_types=None):
        self._id = self._parse_id(_id)
        self._name = name
        self._current_id, self._current = self._parse_id_and_object("current_activity", DbActivity, current)
        self._previous_id, self._previous = self._parse_id_and_object("previous_activity", DbActivity, previous)
        self._job_types = []
        self._active = bool(active)


        if job_types is not None:
            if isinstance(job_types, basestring):
                self.job_types.append(job_types)
            elif isinstance(job_types, collections.Sequence):
                for job_type in job_types:
                    if not isinstance(job_type, basestring):
                        raise DatabaseObjectError("Invalid job type type: {}".format(type(job_type)))
                    self._job_types.append(job_type)
            else:
                raise DatabaseObjectError("Invalid job types type: {}".format(type(job_type)))


    @classmethod
    def collection(cls):
        return "hosts"

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value


    @property
    def current(self):
        if self._current is None and self._current_id is not None:
            self._current = DbActivity.load_object(self._current_id)
        return self._current

    @current.setter
    def current(self, value):
        self._current_id, self._current = self._parse_id_and_object("current_activity",
                                                                    DbActivity,
                                                                    value,
                                                                    self._current)

    @property
    def previous(self):
        if self._previous is None and self._previous_id is not None:
            self._previous = DbActivity.load_object(self._previous_id)
        return self._previous

    @previous.setter
    def previous(self, value):
        self._previous_id, self._previous = self._parse_id_and_object("previous_activity",
                                                                      DbActivity,
                                                                      value,
                                                                      self._previous)

    @property
    def job_types(self):
        return self._job_types

    @job_types.setter
    def job_types(self, value):
        del self._job_types[:]
        if value is not None:
            if isinstance(value, basestring):
                self._job_types.append(value)
            elif isinstance(value, collections.Sequence):
                for job_type in value:
                    if not isinstance(job_type, basestring):
                        raise DatabaseObjectError("Invalid job type: {}".format(type(job_type)))
                    self._job_types.append(job_type)
            else:
                raise DatabaseObjectError("Invalid job_types type: {}".format(type(value)))


    @property
    def active(self):
        return self._active

    @active.setter
    def active(self, value):
        self._active = value

    @classmethod
    def load_dict(cls, dict_obj):

        if dict_obj is None:
            return None
        _id = dict_obj['_id'] if '_id' in dict_obj else None
        name = dict_obj['name'] if 'name' in dict_obj else None
        current = dict_obj['current'] if 'current' in dict_obj else None
        previous = dict_obj['previous'] if 'previous' in dict_obj else None
        job_types = dict_obj['job_types'] if 'job_types' in dict_obj else None
        active = dict_obj['active'] if 'active' in dict_obj else False
        return cls(_id=_id,
                   name=name,
                   current=current,
                   previous=previous,
                   job_types=job_types,
                   active=active)

    @classmethod
    def load_object(cls, obj):
        if obj is None:
            return None
        elif isinstance(obj, ObjectId):
            return cls.load_dict(cls.find(obj))
        elif isinstance(obj, dict):
            return cls.load_dict(obj)
        else:
            raise DatabaseObjectError("Invalid host object type: {}".format(type(obj)))


    def _dump_dict(self):
        host_obj = dict()
        host_obj['_id'] = self._id
        host_obj['name'] = self._name
        host_obj['current'] = self._current_id
        host_obj['previous'] = self._previous_id
        host_obj['job_types'] = self._job_types
        host_obj['active'] = self._active


        return host_obj


    def dump_dict(self):
        return self._dump_dict()

    def update(self):
        db_host = self.find(self._id)

        if db_host is None:
            self.save()
            db_host = self.find(self._id)

        self._name = db_host['name']
        self._current_id, self._current  = self._parse_id_and_object("current", DbActivity, db_host['current'])

        self._previous_id, self._previous = self._parse_id_and_object("previous", DbActivity, db_host['previous'])
        self._job_types = db_host['job_types']
        self._active = db_host['active']

    def save(self):
        host_dict = self._dump_dict()

        return database.save(self.collection(), host_dict)


    def start_new_activity(self,
                           activity_type=None,
                           time_started=None,
                           queue_id=None,
                           job_type=None,
                           job_id=None):

        if not job_type in self._job_types:
            return

        if activity_type is None:
            raise DatabaseObjectError("Cannot create a new activity without an activity type.")

        if queue_id is None:
            raise DatabaseObjectError("Cannot start an activity without a queue to link it to.")


        if time_started is None:
            time_started = time.time()

        #make sure we save the last one before we remove our knowledge of it.
        if self._previous_id is not None:
            if self._previous is None:
                self._previous = DbActivity.load_object(self._previous_id)
            self._previous.save()

        if self._current_id is None:
            new_activity =  DbActivity.create_activity(activity_type=activity_type,
                                                       hostname=self._name,
                                                       queue_id=queue_id,
                                                       time_started=time_started,
                                                       job_type=job_type,
                                                       job_id=job_id)

            self._current_id = new_activity.id
            self._current = new_activity
            self._current.save()
        else:
            if self._current is None:
                self._current = DbActivity.load_object(self._current_id)

            if self._current.activity_type == activity_type:
                return

            if self._current.time_ended is None:
                self._current.time_ended = time_started

            self._previous_id = self._current_id
            self._previous = self._current
            self._previous.save()
            self._current = DbActivity.create_activity(activity_type=activity_type,
                                                       hostname=self._name,
                                                       queue_id=queue_id,
                                                       time_started=time_started,
                                                       job_type=job_type,
                                                       job_id=job_id)

            self._current_id = self._current.id
            self._current.save()

        db_host = database.find_one(self.collection(),
                                    {'_id' : self._id})
        self._active = db_host['active'] if db_host is not None else True

        self.save()


    @classmethod
    def get_host(cls, name=None):
        if name is None:
            return None

        host = database.find_one(cls.collection(),
                                 {'name' : name})

        if host is None:
            return cls(name=name)

        return cls.load_dict(host)


class DbActivity(DatabaseObject):
    def __init__(self,
                 _id = None,
                 activity_type = None,
                 queue_id = None,
                 hostname = None,
                 time_started = None,
                 time_ended = None,
                 job_type = None,
                 job_id = None,
                 ordinal = None):
        self._id = self._parse_id(_id)
        self._queue_id, self._queue = self._parse_id_and_object("queue", DbQueue, queue_id)
        self._activity_type = activity_type
        self._hostname = hostname
        self._time_started = time_started
        self._time_ended = time_ended
        self._job_type = job_type
        self._ordinal = int(ordinal) if ordinal is not None else None

        try:
            if job_id is None:
                self._job_id = None
            elif isinstance(job_id, basestring):
                self._job_id = ObjectId(job_id)
            elif isinstance(job_id, ObjectId):
                self._job_id = job_id
            else:
                raise DatabaseObjectError("Invalid Job Id type: {}".format(type(job_id)))
        except Exception, e:
                raise DatabaseObjectError("Threw '{}' with message: {}".format(type(e), e.message))


    @classmethod
    def collection(cls):
        return "activities"

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        self._id = self._parse_id(value)

    @property
    def activity_type(self):
        return self._activity_type

    @activity_type.setter
    def activity_type(self, value):
        self._activity_type = value

    @property
    def queue(self):
        if self._queue is None and self._queue_id is not None:
            self._queue = DbQueue.load_object(self._queue_id)
        return self._queue

    @queue.setter
    def queue(self, value):
        self._queue_id, self._queue = self._parse_id_and_object('queue', DbQueue, value, self._queue)

    @property
    def hostname(self):
        return self._hostname

    @hostname.setter
    def hostname(self, value):
        self._hostname = value

    @property
    def time_started(self):
        return self._time_started

    @time_started.setter
    def time_started(self, value):
        self._time_started = value

    @property
    def time_ended(self):
        return self._time_ended

    @time_ended.setter
    def time_ended(self, value):
        self._time_ended = value

    @property
    def job_type(self):
        return self._job_type

    @job_type.setter
    def job_type(self, value):
        self._job_type = value

    @property
    def job_id(self):
        return self._job_id

    @job_id.setter
    def job_id(self, value):
        try:
            if value is None:
                self._job_id = None
            elif isinstance(value, basestring):
                self._job_id = ObjectId(value)
            elif isinstance(value, ObjectId):
                self._job_id = value
            else:
                raise DatabaseObjectError("Invalid Job Id type: {} (Hint: this object only accepts id's.\
It does not reference an object later".format(type(value)))
        except Exception, e:
            raise DatabaseObjectError("Threw '{}' with message: {}".format(type(e), e.message))


    @property
    def ordinal(self):
        return self._ordinal

    @ordinal.setter
    def ordinal(self, value):
        raise DatabaseObjectError("You cannot manually set an ordinal. This is done by the database.")

    @classmethod
    def ordinal_collection(cls):
        return "activity_ordinal"

    @classmethod
    def _get_ordinal(cls):
        ret = database.find_and_modify_raw(cls.ordinal_collection(),
                                       query={'_id' : 'activity_ordinal'},
                                       update={'$inc' : {'value' : 1}},
                                       upsert=True,
                                       sort=None,
                                       new=True)
        return ret['value']

    def _dump_dict(self):
        act_dict = dict()
        act_dict['_id'] = self._id
        act_dict['activity_type'] = self._activity_type
        act_dict['queue_id'] = self._queue_id
        act_dict['hostname'] = self._hostname
        act_dict['time_started'] = self._time_started
        act_dict['time_ended'] = self._time_ended
        act_dict['job_type'] = self._job_type
        act_dict['job_id'] = self._job_id
        act_dict['ordinal'] = self._ordinal

        return act_dict

    def dump_dict(self):
        return self._dump_dict()


    @classmethod
    def load_dict(cls, dict_obj):
        if dict_obj is None:
            return None

        _id = dict_obj['_id'] if '_id' in dict_obj else None
        activity_type = dict_obj['activity_type'] \
                        if 'activity_type' in dict_obj\
                        else None
        queue_id = dict_obj['queue_id'] if 'queue_id' in dict_obj else None
        hostname = dict_obj['hostname'] if 'hostname' in dict_obj else None
        time_started = dict_obj['time_started']\
                       if 'time_started' in dict_obj\
                       else None
        time_ended = dict_obj['time_ended'] if 'time_ended' in dict_obj else None
        job_type = dict_obj['job_type'] if 'job_type' in dict_obj else None
        job_id = dict_obj['job_id'] if 'job_id' in dict_obj else None
        ordinal = dict_obj['ordinal'] if 'ordinal' in dict_obj else None

        return cls(_id=_id,
                   activity_type=activity_type,
                   queue_id=queue_id,
                   hostname=hostname,
                   time_started=time_started,
                   time_ended=time_ended,
                   job_type=job_type,
                   job_id=job_id,
                   ordinal=ordinal)


    @classmethod
    def load_object(cls, obj):
        if obj is None:
            return None
        elif isinstance(obj, ObjectId):
            return cls.load_dict(cls.find(obj))
        elif isinstance(obj, dict):
            return cls.load_dict(obj)
        else:
            raise DatabaseObjectError("Invalid activity type: {}".format(type(obj)))

    @classmethod
    def create_activity(cls,activity_type=None,
                        queue_id=None,
                        hostname=None,
                        time_started=None,
                        time_ended=None,
                        job_type=None,
                        job_id=None):

        ordinal = cls._get_ordinal()

        return cls(_id=None,
                   activity_type=activity_type,
                   queue_id=queue_id,
                   hostname=hostname,
                   time_started=time_started,
                   time_ended=time_ended,
                   job_type=job_type,
                   job_id=job_id,
                   ordinal=ordinal)

    def save(self):
        act_dict = self._dump_dict()

        return database.save(self.collection(), act_dict)


