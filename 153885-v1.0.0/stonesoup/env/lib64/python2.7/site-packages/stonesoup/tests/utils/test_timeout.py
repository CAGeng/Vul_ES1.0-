#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
import os
from os.path import dirname as dirname
import sys
import shlex
import shutil
import logging
from nose.tools import assert_equal, assert_in, assert_raises, assert_is_not, with_setup

from stonesoup import scripts
from stonesoup.configuration import configuration
from stonesoup.utils.command import BaseCommand
from stonesoup.utils.timeout import TimeoutMonitor
from stonesoup.utils import texaslogging
from stonesoup.tests.resources import configs

outdir = os.path.join(os.path.abspath(os.sep), 'opt', 'stonesoup', 'test')
working_dir = os.path.join(outdir, 'workspace')
log_dir = os.path.join(working_dir, 'logs')

def setup_test_env():
    """Create test directory and initialize logging.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
    """
    if not os.path.exists(outdir):
        os.mkdir(outdir)
    testconf = os.path.join(dirname(configs.__file__), 'test.conf')
    configuration.create(testconf)
    texaslogging.add_logger()

def teardown_test_env():
    """Remove all test artifacts.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
    """
    if os.path.exists(outdir):
        shutil.rmtree(outdir)

class TestProcess(BaseCommand):
    """
    test handler to test BaseCommand
    """
    def __init__(self, **kwargs):
        self.command = kwargs.pop('command')
        self._logger = logging.getLogger('texas.execute')
        kwargs['envvars'] = {'PATH':'{}:{}'.format(os.environ['PATH'],
                                                   os.path.dirname(
                                                       scripts.__file__))}
        super(TestProcess, self).__init__(**kwargs)

    def _get_log_file_prefix(self):
        """
        Return prefix for used in logfile name generation
        Return:
            Returns a string object
        """
        return "test"

    def _get_command(self):
        """
        Construct a script command to execute as a list

        Returns:
            Returns command to execute on the system as a list object
        """
        command = []
        command.extend(shlex.split(self.command))
        return shlex.split(self.command)

@with_setup(setup_test_env, teardown_test_env)
def test_timeout_add_process():
    """
    Test ability to add a process to timeout
    """
    print >> sys.stderr, sys._getframe().f_code.co_name

    test1 = TestProcess(command="sleep 2000",
                        log_dir=log_dir,
                        working_dir=working_dir)
    monitor = TimeoutMonitor(timeout=2, timer_fd=sys.stderr)
    monitor.add_process(test1)

    # Check good instance
    assert_in(test1, monitor._processes)
    # Check for bad instance
    assert_raises(TypeError, monitor.add_process, 'junk')


@with_setup(setup_test_env, teardown_test_env)
def test_timeout_run():
    """
    Test run by checking timeout_reached value
    """
    print >> sys.stderr, sys._getframe().f_code.co_name

    test1 = TestProcess(command="ping -c 30 localhost",
                        log_dir=log_dir,
                        working_dir=working_dir)
    monitor = TimeoutMonitor(timeout=5)

    test1.start()
    monitor.add_process(test1)
    monitor.start()
    test1.wait()

    # Test to see if we hit timeout
    assert_equal(monitor.timeout_reached, True)
    # Test value of return code
    assert_is_not(test1.get_log_dict()[test1._get_process_name()]['killed'],
                 False)
