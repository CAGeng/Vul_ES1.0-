# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
import os
import sys
import shutil
import unittest

import stonesoup.metadata
from stonesoup.metadata import ExecutionGroup as ProcessGroup
from stonesoup.metadata import ExecutionSchemeType
from stonesoup.metadata import InputType
from stonesoup.execution.control import group
from egtestfunctions import ExecutionGroupTestFunctions

class TestExecutionGroupLaunch(unittest.TestCase):

    def setUp(self):
        """Instantiate the utility class.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
        """
        self.func = ExecutionGroupTestFunctions()
        self.kwargs = self.func.kwargs

    def tearDown(self):
        """Remove all test artifacts.
        Args:
            None.
        Returns:
            None.
        Raises:
            None.
        """
        if os.path.exists(self.func.outdir):
            shutil.rmtree(self.func.outdir)

    def test_ExecutionGroupLaunch(self):
        """Execute a group that launches a script process."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Get paths to stdout and stderr log files.
        id = 'metadata-integration-script1'
        outstd, outerr = self.func.get_stdout_stderr_fpaths(id=id)

        # Create the iopair object
        iopair = stonesoup.metadata.IOPair()
        eg_meta = iopair.pre_processes

        # Create the metadata objects. The script echoes a known string to stdout.
        script_input = self.func.get_metadata_script_eg(id=id)
        meta_inputs = eg_meta.inputs
        meta_inputs.append(script_input)

        # Create and run the ExecutionGroup.
        execute_preprocess = group.ExecutionGroup(
            execgroup=iopair.pre_processes,
            **self.kwargs)
        execute_preprocess.start()
        execute_preprocess.join()

        # Check that stdout is what is expected from the scripts
        with open(outstd, 'r') as f: output = f.read()
        OK = 'metadata-integration-script-stdout'
        self.assertEqual(output, OK)
        # Check that there is no output in stderr
        with open(outerr, 'r') as f: output = f.read()
        OK = ''
        self.assertEqual(output, OK)

    def test_ExecutionGroup_background_process(self):
        """Execute a group that launches a script process in the background."""
        # Script with USE_TEXT echo command
        # currently expects metadata to not support background process
        cmd = "bash -c 'while [ ! -f /opt/stonesoup/workspace/testData/signal_me.plz ]; do sleep 0; done; while read p; do kill -s 10 $p; sleep 0; kill -s 12 $p; done < /opt/stonesoup/workspace/testData/signal_me.plz; rm /opt/stonesoup/workspace/testData/signal_me.plz'"
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Get paths to stdout and stderr log files.
        id = 'metadata-integration-script1'
        outstd, outerr = self.func.get_stdout_stderr_fpaths(id=id)

        # Create the metadata objects.
        iopair = stonesoup.metadata.IOPair()
        eg_meta = iopair.pre_processes
        script_input = self.func.get_metadata_script_eg(id=id, value=cmd)
        meta_inputs = eg_meta.inputs
        meta_inputs.append(script_input)
        self.kwargs['background'] = True

        # Create and run the ExecutionGroup.
        execute_preprocess = group.ExecutionGroup(
            execgroup=iopair.pre_processes,
            **self.kwargs)
        execute_preprocess.start()
        execute_preprocess.join()
        proc = execute_preprocess._processes[0]
        # check to make sure process has not returned
        self.assertEquals(proc.get_return_code(wait=False), None)
        # kill process
        execute_preprocess.kill()

        # check for return code
        self.assertEquals(proc.get_return_code(), 136)
        self.kwargs.pop('background')

    def test_ExecutionGroup_background_processes(self):
        """Execute a group that launches a script process in the background."""
        # Script with USE_TEXT echo command
        # currently expects metadata to not support background process
        cmd = "bash -c 'while [ ! -f /opt/stonesoup/workspace/testData/signal_me.plz ]; do sleep 0; done; while read p; do kill -s 10 $p; sleep 0; kill -s 12 $p; done < /opt/stonesoup/workspace/testData/signal_me.plz; rm /opt/stonesoup/workspace/testData/signal_me.plz'"
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Get paths to stdout and stderr log files.
        id = 'metadata-integration-script1'
        outstd, outerr = self.func.get_stdout_stderr_fpaths(id=id)

        # Create the metadata objects.
        iopair = stonesoup.metadata.IOPair()
        eg_meta = iopair.pre_processes
        background_script = self.func.get_metadata_script_eg(id=id, value=cmd)
        transient_script = self.func.get_script_input(1)
        transient_output = self.func.get_output_path_from_id(1, 'test')
        meta_inputs = eg_meta.inputs
        meta_inputs.append(background_script)
        meta_inputs.append(transient_script[0])
        self.kwargs['background'] = False

        # Create and run the ExecutionGroup.
        execute_preprocess = group.ExecutionGroup(
            execgroup=iopair.pre_processes,
            **self.kwargs)
        background_proc = execute_preprocess._processes[0]
        background_proc.background = True
        execute_preprocess.start()
        execute_preprocess.join()
        # check to make sure background process has not returned
        self.assertEquals(background_proc.get_return_code(wait=False), None)
        # check to make sure transient process did return
        transient_proc = execute_preprocess._processes[1]
        self.assertIsNotNone(transient_proc.get_return_code(wait=False))
        # kill process
        execute_preprocess.kill()

        # check for return code
        self.assertEquals(background_proc.get_return_code(), 136)
        self.kwargs.pop('background')

    def test_S0S0ss1s1(self):
        # Execute a group: under a serial flow, a serial subflow with scripts
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create scripts and input objects and get the paths to stdout and stderr log files.
        type = str(stonesoup.metadata.InputType.script).split(".")[-1]
        script1_stdout_content = "metadata-integration-script1-stdout"
        script1 = "echo -n " + script1_stdout_content
        id = 'metadata-integration-script1'
        script1stdout, script1stderr = self.func.get_stdout_stderr_fpaths(id=id)
        script1_input = self.func.get_metadata_script_eg(value=script1,id=id)
        script2_stdout_content = "metadata-integration-script2-stdout"
        script2 = "echo -n " + script2_stdout_content
        id = 'metadata-integration-script2'
        script2stdout, script2stderr = self.func.get_stdout_stderr_fpaths(id=id)
        script2_input = self.func.get_metadata_script_eg(value=script2,id=id)
        script3_stdout_content = "metadata-integration-script3-stdout"
        script3 = "echo -n " + script3_stdout_content
        id = 'metadata-integration-script3'
        script3stdout, script3stderr = self.func.get_stdout_stderr_fpaths(id=id)
        script3_input = self.func.get_metadata_script_eg(value=script3,id=id)

        # Compose and run the execution group
        eg2 = ProcessGroup(ExecutionSchemeType.sequence)
        eg2.inputs.append(script1_input)
        eg2.inputs.append(script2_input)
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg1.inputs.append(eg2)
        eg1.inputs.append(script3_input)
        self.kwargs['execgroup'] = eg1
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that that standard output matches what was used to create the scripts.
        with open(script1stdout, 'r') as f: script1output = f.read()
        with open(script2stdout, 'r') as f: script2output = f.read()
        with open(script3stdout, 'r') as f: script3output = f.read()
        self.assertEqual(script1output, script1_stdout_content)
        self.assertEqual(script2output, script2_stdout_content)
        self.assertEqual(script3output, script3_stdout_content)

    def test_S0P0ff1s1(self):
        # Execute a group: under a parallel flow, a parallel subflow with file and script.
        print >> sys.stderr, sys._getframe().f_code.co_name
        # Define content to be used in files and scripts
        file1_content = 'metadata-integration-file1-content'
        outfile1 = 'file1-process-out'
        file2_content = 'metadata-integration-file2-content'
        outfile2 = 'file2-process-out'
        script1_stdout_content = "metadata-integration-script1-stdout"
        script1 = "echo -n " + script1_stdout_content

        # Get paths of output files
        type = str(stonesoup.metadata.InputType.file_content).split(".")[-1]
        file1stdout, file1stderr = self.func.get_stdout_stderr_fpaths(type=type)
        file1outpath = os.path.join(self.func.workspace_dir, outfile1)
        if os.path.isfile(file1outpath):
            os.remove(file1outpath)
        file2stdout, file2stderr = self.func.get_stdout_stderr_fpaths(type=type)
        file2outpath = os.path.join(self.func.workspace_dir, outfile2)
        if os.path.isfile(file2outpath):
            os.remove(file2outpath)
        type = str(stonesoup.metadata.InputType.script).split(".")[-1]
        script1stdout, script1stderr = self.func.get_stdout_stderr_fpaths(type=type)

        # Get Input objects
        file_input1 = self.func.get_metadata_file_eg(
            content=file1_content,
            path=outfile1
        )
        file_input2 = self.func.get_metadata_file_eg(
            content=file2_content,
            path=outfile2
        )
        script_input = self.func.get_metadata_script_eg(script1)

        # Compose and run the ExecutionGroup
        eg2 = ProcessGroup(ExecutionSchemeType.parallel)
        eg2.inputs.append(file_input1)
        eg2.inputs.append(file_input2)
        eg1 = ProcessGroup(ExecutionSchemeType.sequence)
        eg1.inputs.append(eg2)
        eg1.inputs.append(script_input)
        self.kwargs['execgroup'] = eg1
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the content of the output files equals that used in the input files and the script.
        with open(file1outpath, 'r') as f: file1output = f.read()
        with open(file2outpath, 'r') as f: file2output = f.read()
        with open(script1stdout, 'r') as f: script1output = f.read()
        self.assertEqual(file1output, file1_content)
        self.assertEqual(file2output, file2_content)
        self.assertEqual(script1output, script1_stdout_content)

    def test_FileContents(self):
        """Initialize and run an ExecutionGroup that launches a file process."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object
        content = 'metadata-integration-file-content'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the content of the output file equals that used in the input file.
        with open(outpath, 'r') as f: output = f.read()
        OK = content
        self.assertEqual(output, OK)

    def test_FileContentsEnv(self):
        """Launch a file process which makes use of an environment variable."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object
        self.kwargs['envvars']['TESTCONTENT'] = 'from-env'
        content = 'env-file-content-$TESTCONTENT'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the TESTCONTENT value was expanded.
        with open(outpath, 'r') as f: output = f.read()
        OK = 'env-file-content-from-env'
        self.assertEqual(output, OK)

    def test_FileContentsChainedEnv(self):
        """Launch a file process that uses an environment variable defined using another environment variable."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object
        self.kwargs['envvars']['TESTSTR'] = 'as-chained-content'
        self.kwargs['envvars']['TESTCONTENT'] = 'from-env-$TESTSTR'
        content = 'env-file-content-$TESTCONTENT'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the TESTCONTENT value was expanded.
        with open(outpath, 'r') as f: output = f.read()
        OK = 'env-file-content-from-env-as-chained-content'
        self.assertEqual(output, OK)

    def test_FileContentsChainedCurlyEnv(self):
        """Launch a file process that uses an environment variable defined
        using another environment variable with curly brackets."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object
        self.kwargs['envvars']['TESTSTR'] = 'as-chained-content'
        self.kwargs['envvars']['TESTCONTENT'] = 'from-env-${TESTSTR}'
        content = 'env-file-content-$TESTCONTENT'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the TESTCONTENT value was expanded.
        with open(outpath, 'r') as f: output = f.read()
        OK = 'env-file-content-from-env-as-chained-content'
        self.assertEqual(output, OK)

    def test_FileContentsChainedCurlyEnvBad(self):
        """Launch a file process that uses an environment variable which
        expands the longer of two matching variables in its definition."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object. The expansion should be on SUBGOOD, not SUB
        self.kwargs['envvars']['SUBGOOD'] = 'as-chained-content'
        self.kwargs['envvars']['SUB'] = 'bad-substitution'
        self.kwargs['envvars']['TESTC'] = 'from-env-$SUBGOOD'
        content = 'env-file-content-$TESTC'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the TESTCONTENT value was expanded.
        with open(outpath, 'r') as f: output = f.read()
        OK = 'env-file-content-from-env-as-chained-content'
        self.assertEqual(output, OK)

    def test_FileContentsChainedCurlyEnvLongBad(self):
        """Launch a file process that uses an environment variable defined using curly
        brackets and which expands the longer of two matching variables in its definition."""
        print >> sys.stderr, sys._getframe().f_code.co_name

        # Create file Input object. The expansion should be on SUBGOOD, not SUB
        self.kwargs['envvars']['SUBSTITUTION'] = 'as-chained-content'
        self.kwargs['envvars']['SUB'] = 'bad-substitution'
        self.kwargs['envvars']['TESTC'] = 'from-env-${SUBSTITUTION}'
        content = 'env-file-content-$TESTC'
        outfile = 'file-process-out'
        file_input = self.func.get_metadata_file_eg(
            content=content,
            path=outfile
        )

        # Add the file Input object to the metadata input array
        eg_meta = self.func.metadata.io_pairs[0].pre_processes
        meta_inputs = eg_meta.inputs
        meta_inputs.append(file_input)
        self.kwargs['execgroup'] = eg_meta

        # Get paths of stdout and stderr log files and file process destination.
        type = str(InputType.file_content).split(".")[-1]
        outstd, outerr = self.func.get_stdout_stderr_fpaths(type)
        outpath = os.path.join(self.func.workspace_dir, outfile)
        if os.path.isfile(outpath):
            os.remove(outpath)

        # Instantiate and run the ExecutionGroup
        eg_obj = group.ExecutionGroup(**self.kwargs)
        eg_obj.start()
        eg_obj.join()

        # Check that the TESTCONTENT value was expanded.
        with open(outpath, 'r') as f: output = f.read()
        OK = 'env-file-content-from-env-as-chained-content'
        self.assertEqual(output, OK)