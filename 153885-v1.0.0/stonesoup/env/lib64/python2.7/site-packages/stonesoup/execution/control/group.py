# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
#
import threading

from stonesoup.utils import texaslogging
from stonesoup.metadata import BaseInput
from stonesoup.metadata import ExecutionGroup as ProcessGroup
from stonesoup.metadata import ExecutionSchemeType

from stonesoup.execution import get_process


class ExecutionGroupException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class ExecutionGroup(threading.Thread):
    """Plans and executes the Execution Group."""

    def __init__(self, **kwargs):
        self.background = False
        stage = kwargs.get('stage')
        self._id = kwargs.pop('id', 'execution-group')
        # Initialization before call of run method
        texaslogging.info(self._id + ' - Starting ExecutionGroup instantiation.')
        threading.Thread.__init__(self)
        self._stop = threading.Event()
        """Takes signal to stop the execution group thread."""
        self._processes = []
        """List of processes to be executed in this group."""
        eg_meta = kwargs.pop('execgroup')
        if not isinstance(eg_meta, ProcessGroup):
            raise TypeError('Invalid input type "{0:s}".'.format(type(eg_meta)))
        self.scheme = eg_meta.scheme

        if eg_meta.has_inputs:
            child_eg = 0
            for meta_input in eg_meta.inputs:
                if isinstance(meta_input, BaseInput):
                    args = kwargs.copy()             # Args from Execute
                    args['input'] = meta_input       # Args from metadata
                    args['background'] = kwargs.get('background', False)
                    proc = get_process(egid=self._id, **args)
                    self.append(proc)
                elif isinstance(meta_input, ProcessGroup):
                    args = kwargs.copy()
                    args['execgroup'] = meta_input
                    args['id'] = self._id + '-' + str(child_eg)
                    child_eg += 1
                    subgroup = ExecutionGroup(**args)
                    self.append(subgroup)
                else:
                    texaslogging.error(self._id + ' - Exception in ExecutionGroup instantiation.')
                    raise TypeError('Invalid input type "{0:s}".'.format(type(meta_input)))
        else:
            texaslogging.warn(self._id + ' - No input classes found in metadata.')


    def __str__(self):
        """String representation of ExecutionGroup instance. Recursively displays parameter values."""
        my_parms = self.scheme
        for proc in self._processes:
            my_parms = my_parms, str(proc)
        return str.replace(str(my_parms), "\'", '\"')

    def __eq__(self, obj):
        """Equals method for this class. Based on string representation."""
        yup = type(obj) is ExecutionGroup
        yup &= (str(self) == str(obj))
        return yup

    def _get_process_name(self):
        """Returns self._id, unique identifier within the execution"""
        return self._id

    def info(self, msg):
        texaslogging.info(self._id + " - " + msg)

    def debug(self, msg):
        texaslogging.debug(self._id + " - " + msg)

    def warn(self, msg):
        texaslogging.warn(self._id + " - " + msg)

    def error(self, msg):
        texaslogging.error(self._id + " - " + msg)

    def get_proc_instance_old(self, args):
        """Finds and returns an instance of the class, by reflection"""
        try:
            proctype = args['input'].type
            self.debug('Instantiating ' + str(proctype))
            proc_class = self._classname[proctype]
            instance = globals()[proc_class](**args)
            return instance
        except Exception as e:
            msg = "Could not get process instance. " + e.message
            self.error(msg)
            raise Exception(msg)

    def append(self, process):
        """Adds a process or execution group to be executed."""
        self._processes.append(process)

    def get_log_dict(self):
        """Recursively returns log file paths of processes."""
        self.debug("Composing log dictionary.")
        logs = {}
        for proc in self._processes:
            logs.update(proc.get_log_dict())
        return logs

    def kill(self):
        """Invokes method to recursively stop all processes."""
        self.stop()

    def stop(self):
        """Kills the processes. Recursive."""
        if self.stopped() is True:
            return
        self._stop.set()
        for proc in self._processes:
            self.debug("Killing process " + proc._get_process_name())
            proc.kill()

    def stopped(self):
        """Current value of stop event."""
        return self._stop.isSet()

    def wait(self):
        """Waits for all processes or sub execution groups in the execution group to finish, then joins its parent"""
        self.debug("Waiting for child processes to finish.")
        for proc in self._processes:
            proc.join()

    def run(self):
        """Invokes the processes or sub execution groups of this ExecutionGroup"""
        self.info("Starting processes.")
        try:
            # Run the execution group in a thread
            for proc in self._processes:
                if self.stopped(): break
                if not isinstance(proc, ExecutionGroup):
                    self.info("Starting process " + str(proc))
                proc.start()
                if self.scheme == ExecutionSchemeType.sequence : proc.join()
            if self.scheme == ExecutionSchemeType.parallel : self.wait()
        except Exception, e:
            self.error("Exception executing processes, " + e.message)
            if not self.stopped(): self.stop()
            #raise ExecutionGroupException("Killed processes due to exception " + e.message)
            # Cause this block to be invoked in parent
        self.info("Finished processes.")
