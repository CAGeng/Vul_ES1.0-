# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------
import collections
import re
import os
import importlib
import itertools
from nose.tools import nottest


from pyxb.utils.domutils import BindingDOMSupport
from pyxb import UnrecognizedContentError, IncompleteElementContentError

from ...utils import MetadataError

from ...enums import ComplexityCategoryType, InputType

__all__ = [ 'MetadataObject',
    'TestCase',
    'BinaryDistribution',
    'TestCaseStructure',
    'CodeLocation',
    'CodeLocationWithDescription',
    'ComplexityFeature',
    'TaintSourceFeature',
    'DataTypeFeature',
    'DataFlowFeature',
    'ControlFlowFeature',
    'Variant',
    'Weakness',
    'SimpleValue',
    'NamedValue',
    'BaseInput',
    'ScriptInput',
    'EnvironmentVariableInput',
    'FileContentInput',
    'SocketInput',
    'DatabaseInput',
    'OutputCheck',
    'SimpleOutputCheck',
    'CompareOutputCheck',
    'ExecutionGroup',
    'IOPair',
    'Actual',
    'Expected' ]

class MetadataObject(object) :
    @classmethod
    def _load_local_module(cls, name) :
        return importlib.import_module('..{0:s}'.format(name), cls.__module__)

@nottest
class TestCase(MetadataObject) :
    def __init__(self,
                 name=None,
                 description=None,
                 base_program=None,
                 language=None,
                 targeted_architecture=None,
                 targeted_os=None,
                 test_case_type=None,
                 run_command=None,
                 structure=None,
                 weakness=None,
                 build_commands=None,
                 build_ldflags=None,
                 build_libs=None,
                 build_cflags=None,
                 build_cppflags=None,
                 io_pairs=None,
                 additional_information=None,
                 resource_limits=None) :

        self._name = name
        self._description = description
        self._base_program = base_program
        self._language = self.parse_language(language)
        self._targeted_architecture = self.parse_targeted_architecture(targeted_architecture)
        self._targeted_os = self.parse_targeted_os(targeted_os)
        self._test_case_type = self.parse_test_case_type(test_case_type)
        self._run_command = run_command
        self._structure = structure
        self._weakness = weakness
        self._build_commands = [ ]
        self._build_ldflags = build_ldflags
        self._build_libs = build_libs
        self._build_cflags = build_cflags
        self._build_cppflags = build_cppflags
        self._io_pairs = [ ]
        self._additional_information = collections.OrderedDict()
        self._resource_limits = collections.OrderedDict()


        self._version = self._xml_spec_version()

        # In the XML, additional information is a sequence of
        # key-value pairs.  We will duplicate this information
        # here to make it easy for developers to program against.
        # This is also analogous to how it is intended to be used
        # as a field.
        if additional_information is not None and\
                isinstance(additional_information, collections.Mapping) :
            self._additional_information.update(additional_information)

        if io_pairs is not None and\
                isinstance(io_pairs, collections.Sequence) :
            for io_pair in io_pairs :
                if not isinstance(io_pair, IOPair) :
                    raise MetadataError('Invalid IO pair type "{0:s}"'.format(io_pair))
                self._io_pairs.append(io_pair)

        if build_commands is not None and\
                isinstance(build_commands, collections.Sequence) :
            self._build_commands.extend(build_commands)

        if resource_limits is not None and\
                isinstance(resource_limits, collections.Mapping) :
            for rlimit_type, rlimit_value in resource_limits.iteritems() :
                self._resource_limits[self.parse_resource_limit(rlimit_type)] = rlimit_value

    @classmethod
    def _xml_spec(cls) :
        return importlib.import_module('....xml.v1_0_0', cls.__module__)

    @classmethod
    def _xml_spec_version(cls) :
        return '1.0.0'

    def __str__(self) :
        return 'Test Case: {0:s} ({1:d} IO Pairs)'.format(self._name, len(self._io_pairs))

    @property
    def version(self) :
        return self._version

    @property
    def name(self) :
        """Gets/sets the test case name.

        Args:
            value (str): the test case name

        Returns:
            str: the test case name, or None

        """
        return self._name

    @name.setter
    def name(self, value) :
        self._name = value

    @property
    def description(self) :
        """Gets/sets the test case description.

        Args:
            value (str): the test case description

        Returns:
            str: the test case description, or None

        """
        return self._description

    @description.setter
    def description(self, value) :
        self._description = value

    @property
    def base_program(self) :
        """Gets/sets the base program name from which this test case is derived.

        Args:
            value (str): the base program name

        Returns:
            str: the base program name, or None

        """
        return self._base_program

    @base_program.setter
    def base_program(self, value) :
        self._base_program = value

    @property
    def language(self) :
        """Gets/sets the primary source language this test case is written with.

        Valid language types are the following defined in
        :class:`LanguageType` as an enumeration.  String equivalents
        are also accepted, and converted to the enumeration value
        automatically.

        Args:
            value (LanguageType): the source language (e.g. C)

        Returns:
            LanguageType: the source language, or None

        """
        return self._language

    @language.setter
    def language(self, value) :
        self._language = self.parse_language(value)

    @property
    def targeted_architecture(self):
        """Gets/sets the type of architecture targeted by this test case.

        Valid architecture types are the following defined in
        :class:`ArchitectureType` as an enumeration.  String equivalents
        are also accepted, and converted to the enumeration value
        automatically.

        Args:
            value (ArchitectureType): the type of architecture (e.g. x86_64)

        Returns:
            ArchitectureType: the type of architecture, or None

        """
        return self._targeted_architecture

    @targeted_architecture.setter
    def targeted_architecture(self, value):
        self._targeted_architecture = self.parse_architecture(value)

    @property
    def targeted_os(self):
        """Gets/sets the type of operating system targeted by this test case.

        Valid operating system types are the following defined in
        :class:`OperatingSystemType` as an enumeration.  String equivalents
        are also accepted, and converted to the enumeration value
        automatically.

        Args:
            value (OperatingSystemType): the type of operating system (e.g. LINUX)

        Returns:
            OperatingSystemType: the type of operating system, or None

        """
        return self._targeted_os

    @targeted_os.setter
    def targeted_os(self, value):
        self._targeted_os = self.parse_targeted_os(value)

    @property
    def test_case_type(self):
        """Gets/sets the type of test case.

        Valid test case types are the following defined in
        :class:`TestCaseType` as an enumeration.  String equivalents
        are also accepted, and converted to the enumeration value
        automatically.

        Args:
            value (TestCaseType): the type of test case (e.g. BINARY)

        Returns:
            TestCaseType: the type of test case, or None

        """
        return self._test_case_type

    @test_case_type.setter
    def test_case_type(self, value):
        self._test_case_type = self.parse_test_case_type(value)

    @property
    def run_command(self):
        """Gets/sets the project run command.

        By default, the project run command is concatenated with the IOPair
        run command to form a full exec command.  In this scenario, the
        project run command may specify a common base command across each
        IOPair to avoid duplicating the same information multiple times.
        However, the IOPair may choose to ignore this value if it will
        specify a full run command at that level.

        For binaries, the run command should specify the absolute path to
        the executable to avoid confusion with system provided executables
        already on the PATH.  The absolute path should be specified using
        pre-defined environment variables (e.g. $SS_TC_ROOT/$SS_TC_INSTALL/
        bin/executable).

        For Java, the classpath members should be specified in the same manner.

        Args:
            command (str):  project run command

        Returns:
            str: project run command
        """
        return self._run_command

    @run_command.setter
    def run_command(self, value):
        self._run_command = value

    @property
    def additional_information(self):
        """Gets/sets the additional information properties.

        Additional information is a dictionary of key value pairs.  Both
        the keys and values are of type basestring.

        Args:
            properties (dict):  project properties

        Returns:
            dict: collection of properties

        Examples:
            Get the current properties for the project.

            >>> for key, value in project.additional_information.iteritems() :
                    ('{0:s}={1:s}'.format(key, value))

            Set new properties.  This will be a shallow copy of the provided
            dictionary.

            >>> project.additional_information = {'key': 'value'}

            Add/update a property.

            >>> project.additional_information['key'] = 'value'

        """
        return self._additional_information

    @additional_information.setter
    def additional_information(self, value):
        self._additional_information.clear()
        if value is not None and\
                isinstance(value, collections.Mapping) :
            self._additional_information.update(value)

    @property
    def build_commands(self):
        """Gets/sets the list of build commands for the project.

        The commands are an iterable of strings.

        Args:
            commands ([iterable]):  new build commands

        Returns:
            [iterable]: Sequence of build commands

        Examples:
            Get the current sequence of build commands.

            >>> for command in project.build_commands :
                    (command)


            Set a single command

            >>> project.build_commands = 'echo "single command"'

            Set multiple commands

            >>> project.build_commands = [ 'echo "first command"',
                    'echo "second command"']

        """
        return self._build_commands

    @build_commands.setter
    def build_commands(self, value):
        # for convenience, this will accept a simple string (one command)
        # or a list of strings.
        del self._build_commands.command[:]
        if isinstance(value, basestring) :
            # this is a single command
            self._build_commands.append(value)
        elif isinstance(value, collections.Sequence) :
            self._build_commands.extend(value)
        else :
            raise MetadataError('Inavlid build commands provided.')

    @property
    def build_ldflags(self) :
        """Gets/sets the LDFLAGS for the build commands.

        Args:
            ldflags (str): build LDFLAGS

        Returns:
            str: build LDFLAGS
        """
        return self._build_ldflags

    @build_ldflags.setter
    def build_ldflags(self, value) :
        self._build_ldflags = value

    @property
    def build_libs(self):
        """Gets/sets the LIBS for the build commands.

        Args:
            libs (str): build LIBS

        Returns:
            str: build LIBS
        """
        return self._build_libs

    @build_libs.setter
    def build_libs(self, value):
        self._build_libs = value

    @property
    def build_cflags(self) :
        """Gets/sets the CFLAGS for the build commands.

        Args:
            ldflags (str): build CFLAGS

        Returns:
            str: build CFLAGS
        """
        return self._build_cflags

    @build_cflags.setter
    def build_cflags(self, value) :
        self._build_cflags = value

    @property
    def build_cppflags(self) :
        """Gets/sets the CPPFLAGS for the build commands.

        Args:
            ldflags (str): build CPPFLAGS

        Returns:
            str: build CPPFLAGS
        """
        return self._build_cppflags

    @build_cppflags.setter
    def build_cppflags(self, value) :
        self._build_cppflags = value

    @property
    def structure(self) :
        return self._structure

    @structure.setter
    def structure(self, value) :
        if value is not None :
            if not isinstance(value, TestCaseStructure) :
                raise MetadataError('Invalid structure type "{0:s}".'.format(type(value)))
            self._structure = value
        else :
            self._structure = None

    @property
    def weakness(self) :
        return self._weakness

    @weakness.setter
    def weakness(self, value) :
        if value is not None :
            if not isinstance(value, Weakness) :
                raise MetadataError('Invalid weakness type "{0:s}".'.format(type(value)))
            self._weakness = value
        else :
            self._weakness = None

    @property
    def resource_limits(self) :
        return self._resource_limits

    @resource_limits.setter
    def resource_limits(self, value) :
        self._resource_limits.clear()
        if value is not None :
            if not isinstance(value, collections.Mapping) :
                raise MetadataError('Invalid resource limits "{0:s}".'.format(type(value)))
            for rlimit_type, rlimit_value in value.iteritems() :
                self._resource_limits[self.parse_resource_limit(rlimit_type)] = rlimit_value

    @property
    def has_resource_limits(self) :
        return len(self._resource_limits) != 0

    @property
    def io_pairs(self):
        return self._io_pairs

    @io_pairs.setter
    def io_pairs(self, value):
        del self._io_pairs[:]
        if value is not None :
            if isinstance(value, collections.Sequence) :
                for item in value :
                    if not isinstance(item, IOPair) :
                        raise MetadataError('Invalid IO pair type "{0:s}".'.format(type(item)))
                    self._io_pairs.append(item)
            elif isinstance(value, IOPair) :
                self._io_pairs.append(value)
            else :
                raise MetadataError('Invalid IO pair type "{0:s}".'.format(type(value)))

    def good_io_pairs(self) :
        good_enum = IOPair.parse_category('GOOD')
        return itertools.ifilter(lambda x: x.category == good_enum, self._io_pairs)

    def bad_io_pairs(self) :
        bad_enum = IOPair.parse_category('BAD')
        return itertools.ifilter(lambda x: x.category == bad_enum, self._io_pairs)

    @property
    def has_good_io_pairs(self) :
        return any(x is not None for x in self.good_io_pairs())

    @property
    def has_bad_io_pairs(self) :
        return any(x is not None for x in self.bad_io_pairs())

    def dump_xml(self, output=None) :
        spec = self._xml_spec()
        xml_obj = self._dump_xml(spec)
        binding = BindingDOMSupport(default_namespace=spec.Namespace)
        try:
            xml_doc = xml_obj.toDOM(bds=binding)
            xml_string = xml_doc.toprettyxml(indent='    ', newl='\n', encoding='utf-8')
        except IncompleteElementContentError:
            raise MetadataError('Testcase cannot be written with incomplete elements.')

        if output is not None :
            if isinstance(output, basestring) :
                with open(output, mode='w') as outstream :
                    outstream.write(xml_string)
            elif hasattr(output, 'write') :
                output.write(xml_string)
            else :
                raise MetadataError('Output stream not supported "{0:s}".'.format(type(output)))
        else :
            return xml_string

    def _dump_xml(self, spec) :
        xml_obj = spec.project()

        xml_obj.name = self._name
        xml_obj.description = self._description
        xml_obj.base_program = self._base_program
        xml_obj.run_command = self._run_command
        xml_obj.language = self._language.value if self._language is not None else None
        xml_obj.targeted_architecture = self._targeted_architecture.value if self._targeted_architecture is not None else None
        xml_obj.targeted_os = self._targeted_os.value if self._targeted_os is not None else None
        xml_obj.test_case_type = self._test_case_type.value if self._test_case_type is not None else None

        if len(self._additional_information) != 0 :
            xml_obj_info = spec.AdditionalInformationType()
            for info_key, info_value in self._additional_information.iteritems() :
                xml_obj_key_pair = spec.KeyValuePairType(info_value)
                xml_obj_key_pair.key = info_key
                xml_obj_info.append(xml_obj_key_pair)
            xml_obj.additional_information = xml_obj_info

        xml_obj.build_commands = spec.BuildCommandType()
        xml_obj.build_commands.ldflags = self._build_ldflags
        xml_obj.build_commands.cflags = self._build_cflags
        xml_obj.build_commands.cppflags = self._build_cppflags
        xml_obj.build_commands.libs = self._build_libs
        for build_command in self._build_commands :
            xml_obj.build_commands.append(build_command)

        if self._structure is not None :
            xml_obj.structure = self._structure.dump_xml(spec)

        if self._weakness is not None :
            xml_obj.weakness.append(self._weakness.dump_xml(spec))

        if len(self._io_pairs) != 0 :
            xml_obj_pairs = spec.IOPairGroupType()
            for io_pair in self._io_pairs :
                xml_obj_pairs.iopair.append(io_pair.dump_xml(spec))
            xml_obj.iopairs = xml_obj_pairs

        if len(self._resource_limits) != 0 :
            xml_obj_rlimits = spec.ResourceLimitsGroupType()

            for rlimit_type, rlimit_value in self._resource_limits.iteritems() :
                xml_obj_rlimit = spec.ResourceLimitKeyValuePairType(rlimit_value)
                xml_obj_rlimit.type = rlimit_type.value
                xml_obj_rlimits.limit.append(xml_obj_rlimit)

            xml_obj.resource_limits = xml_obj_rlimits

        return xml_obj

    def _dump_dict(self, supplied_fields):

        testcase_dict = dict()
        for field in supplied_fields:
                if not hasattr(self, field):
                    raise MetadataError("Invalid attribute: {0:s}".format(field))

                if field == 'io_pairs':
                    if self._io_pairs is not None:
                        io_pairs = list()
                        for io_pair in self._io_pairs:
                            if not isinstance(io_pair, IOPair):
                                raise MetadataError("Invalid IOPair type: {0:s}".format(type(io_pair)))
                            io_pairs.append(io_pair.dump_dict())
                        testcase_dict[field] = io_pairs
                    else:
                        testcase_dict[field] = None

                elif field == 'weakness':
                    if self._weakness is not None:
                        if not isinstance(self._weakness, Weakness):
                            raise MetadataError("Invalid Weakness type:: {0:s}".format(type(self._weakness)))
                        testcase_dict[field] = self._weakness.dump_dict()
                    else:
                        testcase_dict[field] = None

                elif field == 'structure':
                    if self._structure is not None:
                        if not isinstance(self._structure, TestCaseStructure):
                            raise MetadataError("Invalid Test Case Structure: {0:s}".format(type(self._structure)))
                        testcase_dict[field] = self._structure.dump_dict()
                    else:
                        testcase_dict[field] = None
                elif field == 'language':
                    testcase_dict[field] = self._language.value \
                                           if self._language is not None \
                                           else None
                elif field == 'targeted_architecture':
                    testcase_dict[field] = self._targeted_architecture.value \
                                           if self._targeted_architecture is not None \
                                           else None
                elif field == 'targeted_os':
                    testcase_dict[field] = self._targeted_os.value \
                                           if self._targeted_os is not None \
                                           else None
                elif field == 'test_case_type':
                    testcase_dict[field] = self._test_case_type.value \
                                           if self._test_case_type is not None \
                                           else None
                elif field == 'resource_limits':
                    resource_limits = collections.OrderedDict()
                    if self._resource_limits is not None:
                        for key, value in self._resource_limits.iteritems():
                            resource_limits[key.value] = value
                    else:
                        resource_limits = None

                    testcase_dict[field] = resource_limits
                else:
                    testcase_dict[field] = getattr(self, field)

        return testcase_dict

    def dump_dict(self, *args) :
        '''Return a dict containing attributes from the TestCase object
        Args:
            - A list containing all of the fields the user wants from
                  the object. Can either be specified strings, or a list object.
        Returns:
            A dict containing a list of attributes from the object requested
            by the user, or if none are selected, the full list of attributes.
        '''
        valid_fields = set(['name',
                           'description',
                           'base_program',
                           'language',
                           'targeted_architecture',
                           'targeted_os',
                           'test_case_type',
                           'run_command',
                           'structure',
                           'weakness',
                           'build_commands',
                           'build_ldflags',
                           'build_libs',
                           'build_cflags',
                           'build_cppflags',
                           'io_pairs',
                           'additional_information',
                           'resource_limits'])

        supplied_fields= set(args)

        invalid_set = supplied_fields.difference(valid_fields)

        if len(invalid_set) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(args)))


        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_language(cls, language) :
        if language is None :
            return None
        elif isinstance(language, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.LanguageType[language]
            except ValueError :
                raise MetadataError('Invalid language "{0:s}".'.format(language))
        else :
            return language

    @classmethod
    def parse_targeted_architecture(cls, architecture) :
        if architecture is None :
            return None
        elif isinstance(architecture, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ArchitectureType[architecture]
            except ValueError :
                raise MetadataError('Invalid architecture type "{0:s}".'.format(architecture))
        else :
            return architecture

    @classmethod
    def parse_targeted_os(cls, targeted_os) :
        if targeted_os is None :
            return None
        elif isinstance(targeted_os, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.OperatingSystemType[targeted_os]
            except ValueError :
                raise MetadataError('Invalid operating system "{0:s}".'.format(targeted_os))
        else :
            return targeted_os

    @classmethod
    def parse_test_case_type(cls, test_case_type) :
        if test_case_type is None :
            return None
        elif isinstance(test_case_type, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.TestCaseType[test_case_type]
            except ValueError :
                raise MetadataError('Invalid test case type "{0:s}".'.format(test_case_type))
        else :
            return test_case_type

    @classmethod
    def parse_resource_limit(cls, resource_limit) :
        if resource_limit is None :
            return None
        elif isinstance(resource_limit, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ResourceLimitType[resource_limit]
            except ValueError :
                raise MetadataError('Invalid resource limit type "{0:s}".'.format(resource_limit))
        else :
            return resource_limit

    @classmethod
    def _load_xml(cls, xml_obj, spec) :
        additional_information = None
        build_commands = None
        build_ldflags = None
        build_cflags = None
        build_cppflags = None
        build_libs = None
        structure = None
        weakness = None
        io_pairs = None
        resource_limits = None

        if xml_obj.additional_information is not None :
            additional_information = collections.OrderedDict()
            for item in xml_obj.additional_information.orderedContent() :
                additional_information[item.value.key] = item.value.value()

        if xml_obj.build_commands is not None :
            build_commands = [ ]
            build_ldflags = xml_obj.build_commands.ldflags
            build_cflags = xml_obj.build_commands.cflags
            build_cppflags = xml_obj.build_commands.cppflags
            build_libs = xml_obj.build_commands.libs
            for item in xml_obj.build_commands.orderedContent() :
                build_commands.append(item.value)

        if xml_obj.structure is not None :
            structure = TestCaseStructure.load_xml(xml_obj.structure, spec)

        if xml_obj.weakness is not None and\
                len(xml_obj.weakness) != 0 :
            weakness = Weakness.load_xml(xml_obj.weakness[0], spec)

        if xml_obj.iopairs is not None :
            io_pairs = [ ]
            for item in xml_obj.iopairs.iopair :
                io_pairs.append(IOPair.load_xml(item, spec))

        if xml_obj.resource_limits is not None :
            resource_limits = collections.OrderedDict()
            for limit in xml_obj.resource_limits.limit :
                resource_limits[limit.type] = limit.value()

        return cls(name=xml_obj.name,
                   description=xml_obj.description,
                   base_program=xml_obj.base_program,
                   language=xml_obj.language,
                   targeted_architecture=xml_obj.targeted_architecture,
                   targeted_os=xml_obj.targeted_os,
                   test_case_type=xml_obj.test_case_type,
                   run_command=xml_obj.run_command,
                   structure=structure,
                   weakness=weakness,
                   build_commands=build_commands,
                   build_ldflags=build_ldflags,
                   build_libs=build_libs,
                   build_cflags=build_cflags,
                   build_cppflags=build_cppflags,
                   io_pairs=io_pairs,
                   additional_information=additional_information,
                   resource_limits=resource_limits)

    @classmethod
    def load_xml(cls, input, is_file=True) :
        if input is None :
            return None

        xml_text = None

        if is_file :
            if isinstance(input, basestring) :
                with open(input, mode='r') as instream :
                    xml_text = instream.read()
            elif hasattr(input, 'read') :
                xml_text = input.read()
            else :
                raise MetadataError('Input stream not supported "{0:s}".'.format(type(input)))
        else :
            xml_text = input

        spec = cls._xml_spec()

        try:
            return cls._load_xml(spec.CreateFromDocument(xml_text), spec)
        except UnrecognizedContentError:
            raise MetadataError('XML File failed validation.')
        except IncompleteElementContentError:
            raise MetadataError('XML File contains incomplete elements.')


class BinaryDistribution(MetadataObject) :
    def __init__(self,
                 folder=None,
                 architecture=None) :
        self._folder = folder
        self._architecture = self.parse_architecture(architecture)

    def __str__(self) :
        return 'Binary Distribution: {0:s} ({1:s})'.format(self._folder, self._architecture.value if self._architecture is not None else 'UNKNOWN')

    @property
    def architecture(self) :
        return self._architecture

    @architecture.setter
    def architecture(self, value) :
        self._architecture = self.parse_architecture(value)

    @property
    def folder(self) :
        return self._folder

    @folder.setter
    def folder(self, value) :
        self._folder = value


    def dump_xml(self, spec) :
        xml_obj = spec.BinaryDistributionType(self._folder)
        xml_obj.architecture = self._architecture.value if self._architecture is not None else None
        return xml_obj

    @classmethod
    def parse_architecture(cls, architecture) :
        if architecture is None :
            return None
        elif isinstance(architecture, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ArchitectureType[architecture]
            except ValueError :
                raise MetadataError('Invalid architecture type "{0:s}".'.format(architecture))
        else :
            return architecture

    def _dump_dict(self, supplied_fields):
        binary_dict = dict()
        if 'folder' in supplied_fields:
            binary_dict['folder'] = self._folder

        if 'architecture' in supplied_fields:
            binary_dict['architecture'] = self._architecture.value \
                                         if self._architecture is not None \
                                         else None

        return binary_dict

    def dump_dict(self, *args):
        valid_fields = set(['folder',
                           'architecture'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.BinaryDistributionType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        return cls(xml_obj.value(), xml_obj.architecture)


class TestCaseStructure(MetadataObject) :
    def __init__(self,
                 source='src',
                 install='install',
                 scripts='scripts',
                 iodata='testData',
                 scoredata='testOutput',
                 binaries=None) :
        self._source = source
        self._install = install
        self._scripts = scripts
        self._iodata = iodata
        self._scoredata = scoredata
        self._binaries = [ ]
        if binaries is not None :
            if isinstance(binaries, collections.Sequence) :
                self._binaries.extend(binaries)
            else :
                self._binaries.add(binaries)

    @property
    def source(self) :
        return self._source

    @source.setter
    def source(self, value) :
        self._source = value

    @property
    def install(self) :
        return self._install

    @install.setter
    def install(self, value) :
        self._install = value

    @property
    def scripts(self) :
        return self._scripts

    @scripts.setter
    def scripts(self, value) :
        self._scripts = value

    @property
    def iodata(self) :
        return self._iodata

    @iodata.setter
    def iodata(self, value) :
        self._iodata = value

    @property
    def scoredata(self) :
        return self._scoredata

    @scoredata.setter
    def scoredata(self, value) :
        self._scoredata = value

    @property
    def binaries(self) :
        return self._binaries

    @binaries.setter
    def binaries(self, value) :
        del self._binaries[:]
        if value is None :
            return
        if isinstance(value, collections.Sequence) :
            self._binaries.extend(value)
        elif isinstance(value, BinaryDistribution):
            self._binaries.add(value)

    def dump_xml(self, spec) :
        xml_obj = spec.TestCaseStructureType()

        xml_obj.source = self._source
        xml_obj.install = self._install
        xml_obj.scripts = self._scripts
        xml_obj.iodata = self._iodata
        xml_obj.scoredata = self._scoredata

        for binary in self._binaries :
            xml_obj.binary.append(binary.dump_xml(spec))

        return xml_obj

    def _dump_dict(self, supplied_fields):
        structure_dict = dict()
        for field in supplied_fields:
            if field == 'binaries':
                binaries = list()
                if self._binaries is not None:
                    for binary in self._binaries:
                        if not isinstance(binary, BinaryDistribution):
                            raise MetadataError("Invalid Binary Distribution: {0:s}".format(type(binary)))
                        binaries.append(binary.dump_dict())
                structure_dict[field] = binaries
            else:
                structure_dict[field] = getattr(self, field)

        return structure_dict

    def dump_dict(self, *args):
        valid_fields = set(['source',
                           'install',
                           'scripts',
                           'iodata',
                           'scoredata',
                           'binaries'])

        supplied_fields= set(args)

        invalid_set = supplied_fields.difference(valid_fields)

        if len(invalid_set) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(args)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.TestCaseStructureType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        binaries = None

        if xml_obj.binary is not None and\
                len(xml_obj.binary) != 0 :
            binaries = [ ]
            for item in xml_obj.binary :
                binaries.append(BinaryDistribution.load_xml(item, spec))

        return cls(source=xml_obj.source,
                   install=xml_obj.install,
                   scripts=xml_obj.scripts,
                   iodata=xml_obj.iodata,
                   scoredata=xml_obj.scoredata,
                   binaries=binaries)


class CodeLocation(MetadataObject):
    def __init__(self,
                 file_name=None,
                 method_name=None,
                 line_number=None,
                 class_name=None,
                 parameters=None) :

        self._file_name = file_name
        self._method_name = method_name
        self._class_name = class_name
        self._line_number = None
        self._parameters = [ ]

        if line_number is not None :
            self._line_number = int(line_number)

        # parameters are a sequence of strings
        if parameters is not None :
            if isinstance(parameters, collections.Sequence) :
                self._parameters.extend(parameters)

    def __str__(self) :
        method = ''
        if self._method_name is not None :
            method = ' - {0:s}({1:s})'.format(self._method_name, ', '.join(self._parameters))
        return 'Code Location: {0:d} {1:s} {2:s}'.format(self._line_number if self._line_number is not None else -1,
            self._file_name,
            method)

    @property
    def file_name(self):
        return self._file_name

    @file_name.setter
    def file_name(self, value):
        self._file_name = value

    @property
    def method_name(self):
        return self._method_name

    @method_name.setter
    def method_name(self, value):
        self._method_name = value

    @property
    def class_name(self):
        return self._class_name

    @class_name.setter
    def class_name(self, value):
        self._class_name = value

    @property
    def line_number(self):
        return self._line_number

    @line_number.setter
    def line_number(self, value):
        self._line_number = value

    @property
    def parameters(self):
        return self._parameters

    @parameters.setter
    def parameters(self, value):
        del self._parameters[:]
        if value is None :
            return
        if isinstance(value, collections.Sequence) :
            self._parameters.extend(value)

    def _create_xml_obj(self, spec) :
        return spec.CodeLocationType()

    def dump_xml(self, spec) :
        xml_obj = self._create_xml_obj(spec)

        xml_obj.file_name = self._file_name
        xml_obj.line_number = self._line_number

        # only create method information if required
        if self._method_name is not None or\
                self._class_name is not None or\
                len(self._parameters) > 0 :
            xml_obj_method = spec.MethodType()
            xml_obj_method.name = self._method_name
            xml_obj_method.classname = self._class_name

            for param in self._parameters :
                xml_obj_method.parameter.append(param)

            xml_obj.method = xml_obj_method

        return xml_obj

    def _get_base_fields(self):
        return set(['file_name',
                   'method_name',
                   'class_name',
                   'line_number',
                   'parameters'])

    def _dump_dict(self, supplied_fields):
        code_dict = dict()
        for field in supplied_fields:
            code_dict[field] = getattr(self, field)

        return code_dict

    def dump_dict(self, *args):
        valid_fields = self._get_base_fields()
        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.CodeLocationType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        parameters = None
        method_name = None
        class_name = None

        if xml_obj.method is not None :
            parameters = [ ]
            method_name = xml_obj.method.name
            class_name = xml_obj.method.classname
            for param in xml_obj.method.parameter :
                parameters.append(param)

        return cls(file_name=xml_obj.file_name,
                   method_name=method_name,
                   line_number=xml_obj.line_number,
                   class_name=class_name,
                   parameters=parameters)


class CodeLocationWithDescription(CodeLocation):
    def __init__(self,
                 file_name=None,
                 method_name=None,
                 line_number=None,
                 class_name=None,
                 parameters=None,
                 description=None):
        super(CodeLocationWithDescription, self).__init__(
            file_name=file_name,
            method_name=method_name,
            line_number=line_number,
            class_name=class_name,
            parameters=parameters)

        self._description = description

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        self._description = value

    def _create_xml_obj(self, spec) :
        return spec.CodeLocationWithDescriptionType()

    def dump_xml(self, spec) :
        xml_obj = super(CodeLocationWithDescription, self).dump_xml(spec)

        xml_obj.description = self._description

        return xml_obj

    def _dump_dict(self, supplied_fields):
        #Must ensure we pass up only the fields we want from the base class.
        base_fields = supplied_fields.intersection(self._get_base_fields())
        code_dict = super(CodeLocationWithDescription, self)._dump_dict(list(base_fields))

        if 'description' in supplied_fields:
            code_dict['description'] = self._description

        return code_dict

    def dump_dict(self, *args):
        valid_fields = set(['file_name',
                           'method_name',
                           'line_number',
                           'class_name',
                           'parameters',
                           'description'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)


    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.CodeLocationWithDescriptionType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        # the super classmethod will use the referenced type, so it will
        # actually create an object of this type.  we only need to set
        # the description later
        location = super(CodeLocationWithDescription, cls).load_xml(xml_obj, spec)
        location.description = xml_obj.description

        return location


class ComplexityFeature(CodeLocation):
    def __init__(self,
                 file_name=None,
                 method_name=None,
                 line_number=None,
                 class_name=None,
                 parameters=None,
                 complexity_type=None):
        super(ComplexityFeature, self).__init__(
            file_name=file_name,
            method_name=method_name,
            line_number=line_number,
            class_name=class_name,
            parameters=parameters)

        self._complexity_type = self.parse_complexity_type(complexity_type)

    @classmethod
    def _load_complexity_enum(cls) :
        raise MetadataError('Complexity enumeration not implemented.')

    @property
    def complexity_type(self):
        return self._complexity_type

    @complexity_type.setter
    def complexity_type(self, value):
        self._complexity_type = self.parse_complexity_type(value)

    @property
    def complexity_category(self) :
        raise MetadataError('Complexity category not implemented.')

    def _create_xml_obj(self, spec) :
        raise MetadataError('Complexity feature XML object creation not implemented.')

    def dump_xml(self, spec) :
        xml_obj = super(ComplexityFeature, self).dump_xml(spec)

        xml_obj.type = self._complexity_type.value if self._complexity_type is not None else None

        return xml_obj


    def _dump_dict(self, supplied_fields):
        #Must ensure we pass up only the fields we want from the base class.
        base_fields = supplied_fields.intersection(self._get_base_fields())
        complexity_dict = super(ComplexityFeature, self)._dump_dict(list(base_fields))

        if 'complexity_type' in supplied_fields:
            complexity_dict['complexity_type'] = self._complexity_type.value if \
                                                 self._complexity_type is not None \
                                                 else None
        return complexity_dict

    def dump_dict(self, *args):
        valid_fields = set(['file_name',
                           'method_name',
                           'line_number',
                           'class_name',
                           'parameters',
                           'complexity_type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_complexity_type(cls, complexity) :
        if complexity is None :
            return None
        elif isinstance(complexity, basestring) :
            _enum = cls._load_complexity_enum()
            try :
                return _enum[complexity]
            except ValueError :
                raise MetadataError('Invalid {0:s} "{1:s}".'.format(_enum.__name__, complexity))
        else :
            return complexity

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.TaintSourceLocationType) and\
                not isinstance(xml_obj, spec.DataTypeLocationType) and\
                not isinstance(xml_obj, spec.DataFlowLocationType) and\
                not isinstance(xml_obj, spec.ControlFlowLocationType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        # the super classmethod will use the referenced type, so it will
        # actually create an object of this type.  we only need to set
        # the description later
        feature = super(ComplexityFeature, cls).load_xml(xml_obj, spec)
        feature.complexity_type = xml_obj.type

        return feature


class TaintSourceFeature(ComplexityFeature) :
    @classmethod
    def _load_complexity_enum(cls) :
        _enums = cls._load_local_module('enums')
        return _enums.TaintSourceType

    @property
    def complexity_category(self) :
        return ComplexityCategoryType.taint_source

    def _create_xml_obj(self, spec) :
        return spec.TaintSourceLocationType()

    def dump_dict(self, *args):
        feature_dict = super(TaintSourceFeature, self).dump_dict(*args)

        feature_dict['complexity_category'] = self.complexity_category.value \
                                              if self.complexity_category is not None \
                                              else None
        return feature_dict



class DataTypeFeature(ComplexityFeature) :
    @classmethod
    def _load_complexity_enum(cls) :
        _enums = cls._load_local_module('enums')
        return _enums.DataType

    @property
    def complexity_category(self) :
        return ComplexityCategoryType.data_type

    def _create_xml_obj(self, spec, use_type=False) :
        if use_type:
            return spec.DataTypeLocationType()
        else:
            return spec.data_type()

    def dump_dict(self, *args):
        feature_dict = super(DataTypeFeature, self).dump_dict(*args)

        feature_dict['complexity_category'] = self.complexity_category.value \
                                              if self.complexity_category is not None \
                                              else None

        return feature_dict


class DataFlowFeature(ComplexityFeature) :
    @classmethod
    def _load_complexity_enum(cls) :
        _enums = cls._load_local_module('enums')
        return _enums.DataFlowType

    @property
    def complexity_category(self) :
        return ComplexityCategoryType.data_flow

    def _create_xml_obj(self, spec, use_type=False) :
        if use_type:
            return spec.DataFlowLocationType()
        else:
            return spec.data_flow()


    def dump_dict(self, *args):
        feature_dict = super(DataFlowFeature, self).dump_dict(*args)

        feature_dict['complexity_category'] = self.complexity_category.value \
                                              if self.complexity_category is not None \
                                              else None
        return feature_dict

class ControlFlowFeature(ComplexityFeature) :

    @classmethod
    def _load_complexity_enum(cls) :
        _enums = cls._load_local_module('enums')
        return _enums.ControlFlowType

    @property
    def complexity_category(self) :
        return ComplexityCategoryType.control_flow

    def _create_xml_obj(self, spec, use_type=False) :
        if use_type:
            return spec.ControlFlowLocationType()
        else:
            return spec.control_flow()


    def dump_dict(self, *args):
        feature_dict = super(ControlFlowFeature, self).dump_dict(*args)

        feature_dict['complexity_category'] = self.complexity_category.value \
                                              if self.complexity_category is not None \
                                              else None
        return feature_dict



class Variant(MetadataObject) :
    def __init__(self,
                 name=None,
                 cwe=None,
                 interaction_point=None,
                 crossover_point=None,
                 trigger_point=None,
                 description=None) :
        self._cwe_pattern = re.compile('^[A-Z]{3}-[0-9]{1,3}$')
        self._name = name
        self._cwe = cwe
        self._interaction_point = interaction_point
        self._crossover_point = crossover_point
        self._trigger_point = trigger_point
        self._description = description

        if interaction_point is not None :
            if not isinstance(interaction_point, CodeLocationWithDescription) :
                raise MetadataError('Invalid interaction point.')

        if crossover_point is not None :
            if not isinstance(crossover_point, CodeLocationWithDescription) :
                raise MetadataError('Invalid crossover point.')

        if trigger_point is not None :
            if not isinstance(trigger_point, CodeLocationWithDescription) :
                raise MetadataError('Invalid trigger point.')

        if cwe is not None :
            if self._cwe_pattern.match(cwe) is None :
                raise MetadataError('Invalid CWE format.')

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def cwe(self):
        return self._cwe

    @cwe.setter
    def cwe(self, value):
        if value is not None :
            if self._cwe_pattern.match(value) is None :
                raise MetadataError('Invalid CWE format.')
        self._cwe = value

    @property
    def interaction_point(self) :
        return self._interaction_point

    @interaction_point.setter
    def interaction_point(self, value) :
        self._interaction_point = value

        if value is not None :
            if not isinstance(value, CodeLocationWithDescription) :
                raise MetadataError('Invalid interaction point.')

    @property
    def crossover_point(self) :
        return self._crossover_point

    @crossover_point.setter
    def crossover_point(self, value) :
        self._crossover_point = value

        if value is not None :
            if not isinstance(value, CodeLocationWithDescription) :
                raise MetadataError('Invalid crossover point.')

    @property
    def trigger_point(self) :
        return self._trigger_point

    @trigger_point.setter
    def trigger_point(self, value) :
        self._trigger_point = value

        if value is not None :
            if not isinstance(value, CodeLocationWithDescription) :
                raise MetadataError('Invalid trigger point.')

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        self._description = value

    def dump_xml(self, spec) :
        xml_obj = spec.VariantType()

        xml_obj.name = self._name
        xml_obj.cwe = self._cwe
        xml_obj.description = self._description

        if self._interaction_point is not None :
            xml_obj.interaction_point = self._interaction_point.dump_xml(spec)

        if self._crossover_point is not None :
            xml_obj.crossover_point = self._crossover_point.dump_xml(spec)

        if self._trigger_point is not None :
            xml_obj.trigger_point = self._trigger_point.dump_xml(spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        variant_dict = dict()
        for field in supplied_fields:
            if field == 'interaction_point':
                if self._interaction_point is not None:
                    if not isinstance(self._interaction_point, CodeLocationWithDescription) :
                        raise MetadataError('Invalid interaction point.')
                    variant_dict[field] = self._interaction_point.dump_dict()
                else:
                    variant_dict[field] = None
            elif field == 'crossover_point':
                if self._crossover_point is not None:
                    if not isinstance(self._crossover_point, CodeLocationWithDescription) :
                        raise MetadataError('Invalid crossover point.')
                    variant_dict[field] = self._crossover_point.dump_dict()
                else:
                    variant_dict[field] = None
            elif field == 'trigger_point':
                if self._trigger_point is not None:
                    if not isinstance(self._trigger_point, CodeLocationWithDescription) :
                        raise MetadataError('Invalid trigger point.')
                    variant_dict[field] = self._trigger_point.dump_dict()
                else:
                    variant_dict[field] = None
            else:
                variant_dict[field] = getattr(self, field)

        return variant_dict

    def dump_dict(self, *args):
        valid_fields = set(['name',
                           'cwe',
                           'interaction_point',
                           'trigger_point',
                           'crossover_point',
                           'description'])


        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)


    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.VariantType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        return cls(xml_obj.name,
                   xml_obj.cwe,
                   interaction_point=CodeLocationWithDescription.load_xml(xml_obj.interaction_point, spec),
                   crossover_point=CodeLocationWithDescription.load_xml(xml_obj.crossover_point, spec),
                   trigger_point=CodeLocationWithDescription.load_xml(xml_obj.trigger_point, spec),
                   description=xml_obj.description)


class Weakness(MetadataObject) :
    def __init__(self,
                 variant=None,
                 source=None,
                 generation_method=None,
                 injection_point=None,
                 complexities=None) :
        self._variant = variant
        self._source = source
        self._generation_method = self.parse_generation_method(generation_method)
        self._injection_point = injection_point
        self._complexities = [ ]

        if source is not None :
            if not isinstance(source, TaintSourceFeature) :
                raise MetadataError('Taint source must be of type TaintSourceFeature.')

        if complexities is not None and\
                isinstance(complexities, collections.Sequence) :
            for complexity in complexities :
                if not isinstance(complexity, ComplexityFeature) :
                    raise MetadataError('Complexities must be of type DataTypeFeature, DataFlowFeature, or ControlFlowFeature.')
                self._complexities.append(complexity)

    @property
    def variant(self) :
        return self._variant

    @variant.setter
    def variant(self, value) :
        self._variant = value

    @property
    def source(self) :
        return self._source

    @source.setter
    def source(self, value) :
        self._source = value

    @property
    def generation_method(self) :
        return self._generation_method

    @generation_method.setter
    def generation_method(self, value) :
        self._generation_method = self.parse_generation_method(value)

    @property
    def injection_point(self) :
        return self._injection_point

    @injection_point.setter
    def injection_point(self, value) :
        if value is not None:
            if not isinstance(value, CodeLocation):
                raise MetadataError("Invalid injection point of type: {0:s}".format(type(value)))
            self._injection_point = value
        else:
            self._injection_point = None

    @property
    def complexities(self) :
        return self._complexities

    @complexities.setter
    def complexities(self, value) :
        del self._complexities[:]

        if value is not None and\
                isinstance(value, collections.Sequence) :
            for complexity in value :
                if not isinstance(complexity, ComplexityFeature) :
                    raise MetadataError('Complexities must be of type DataTypeFeature, DataFlowFeature, or ControlFlowFeature.')
                self._complexities.append(complexity)

    def dump_xml(self, spec) :
        xml_obj = spec.WeaknessType()

        xml_obj.variant = self._variant.dump_xml(spec)

        if self._injection_point is not None :
            xml_obj.seed_injection_point = self._injection_point.dump_xml(spec)

        xml_obj.generation_method = self._generation_method.value if self._generation_method is not None else None

        xml_obj_features = spec.FeaturesType()
        xml_obj_features.append(self._source.dump_xml(spec))

        for complexity in self._complexities :
            xml_obj_features.complexity.append(complexity.dump_xml(spec))

        xml_obj.features = xml_obj_features

        return xml_obj

    def _dump_dict(self, supplied_fields):
        weakness_dict = dict()
        for field in supplied_fields:
            if field == 'variant':
                if self._variant is not None:
                    if not isinstance(self._variant, Variant):
                        raise MetadataError("Invalid variant type: {0:s}".format(type(self._variant)))
                    weakness_dict[field] = self._variant.dump_dict()
                else:
                    weakness_dict[field] = None
            elif field == 'source':
                if self._source is not None:
                    if not isinstance(self._source, TaintSourceFeature):
                        raise MetadataError("Invalid taint source feature: {0:s}".format(type(self._source)))
                    weakness_dict[field] = self._source.dump_dict()
                else:
                    weakness_dict[field] = None
            elif field == 'generation_method':
                weakness_dict[field] = self._generation_method.value \
                                       if self._generation_method is not None \
                                       else None
            elif field == 'injection_point':
                if self._injection_point is not None:
                    if not isinstance(self._injection_point, CodeLocation):
                        raise MetadataError("Invalid injection point type: {0:s}".format(type(self._injection_point)))
                    weakness_dict[field] = self._injection_point.dump_dict()
                else:
                    weakness_dict[field] = None
            elif field == 'complexities':
                complexities = list()
                if self._complexities is not None:
                    if not isinstance(self._complexities, collections.Sequence):
                        raise MetadataError("Invalid complexities type: {0:s}".format(type(complexities)))
                    for complexity in self._complexities:
                        if not isinstance(complexity, ComplexityFeature) :
                            raise MetadataError('Complexities must be of type DataTypeFeature, DataFlowFeature, or ControlFlowFeature.')
                        complexities.append(complexity.dump_dict())
                    weakness_dict[field] = complexities
            else:
                raise MetadataError("Invalid attribute: {0:s}".format(field))


        return weakness_dict

    def dump_dict(self, *args):
        valid_fields = set(['variant',
                           'source',
                           'generation_method',
                           'injection_point',
                           'complexities'])


        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)


    @classmethod
    def parse_generation_method(cls, generation_method) :
        if generation_method is None :
            return None
        elif isinstance(generation_method, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.GenerationMethodType[generation_method]
            except ValueError :
                raise MetadataError('Invalid generation method "{0:s}".'.format(generation_method))
        else :
            return generation_method

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.WeaknessType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        features_count = 0
        complexities = None
        source = None

        if xml_obj.features is not None :
            features_count = len(xml_obj.features.orderedContent())

        if features_count > 0 :
            source = TaintSourceFeature.load_xml(xml_obj.features.orderedContent()[0].value, spec)

        if features_count > 1 :
            complexities = [ ]
            for feature in xml_obj.features.orderedContent():
                real_feature = feature.value
                if isinstance(real_feature, spec.TaintSourceLocationType) :
                    pass
                elif isinstance(real_feature, spec.DataTypeLocationType) :
                    complexities.append(DataTypeFeature.load_xml(real_feature, spec))
                elif isinstance(real_feature, spec.DataFlowLocationType) :
                    complexities.append(DataFlowFeature.load_xml(real_feature, spec))
                elif isinstance(real_feature, spec.ControlFlowLocationType) :
                    complexities.append(ControlFlowFeature.load_xml(real_feature, spec))
                else :
                    raise MetadataError('Attempt to parse an unsupported code complexity feature "{0:s}"'.format(type(xml_obj)))

        return cls(variant=Variant.load_xml(xml_obj.variant, spec),
                   source=source,
                   generation_method=xml_obj.generation_method,
                   injection_point=CodeLocation.load_xml(xml_obj.seed_injection_point, spec),
                   complexities=complexities)


class SimpleValue(MetadataObject) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT') :
        self._value = value
        self._encoding = self.parse_encoding(encoding)
        self._handling = self.parse_handling(handling)

    @property
    def value(self) :
        return self._value

    @value.setter
    def value(self, value) :
        self._value = value

    @property
    def encoding(self) :
        return self._encoding

    @encoding.setter
    def encoding(self, value) :
        self._encoding = self.parse_encoding(value)

    @property
    def handling(self) :
        return self._handling

    @handling.setter
    def handling(self, value) :
        self._handling = self.parse_handling(value)

    def _create_xml_obj(self, spec) :
        return spec.ValueWithType(self._value)

    def dump_xml(self, spec) :
        xml_obj = self._create_xml_obj(spec)

        xml_obj.encoding = self._encoding.value if self._encoding is not None else None
        xml_obj.type = self._handling.value if self._handling is not None else None

        return xml_obj

    @classmethod
    def parse_encoding(cls, encoding) :
        if encoding is None :
            return None
        elif isinstance(encoding, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.EncodingType[encoding]
            except ValueError :
                raise MetadataError('Invalid encoding "{0:s}".'.format(encoding))
        else :
            return encoding

    @classmethod
    def parse_handling(cls, handling) :
        if handling is None :
            return None
        elif isinstance(handling, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ValueType[handling]
            except ValueError :
                raise MetadataError('Invalid value handling type "{0:s}".'.format(handling))
        else :
            return handling

    def _get_base_fields(self):
        return set(['value',
                   'encoding',
                   'handling'])

    def _dump_dict(self, supplied_fields):
        simple_dict = dict()
        for field in supplied_fields:
            if field == "encoding":
                simple_dict[field] = self._encoding.value \
                                     if self._encoding is not None \
                                     else None
            elif field == "handling":
                simple_dict[field] = self._handling.value \
                                     if self._handling is not None \
                                     else None
            else:
                simple_dict[field] = getattr(self, field)

        return simple_dict

    def dump_dict(self, *args):
        valid_fields = self._get_base_fields()

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(",".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ValueWithType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        return cls(value=xml_obj.value(),
                   encoding=xml_obj.encoding,
                   handling=xml_obj.type)


class NamedValue(SimpleValue) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None) :
        super(NamedValue, self).__init__(value=value,
            encoding=encoding,
            handling=handling)
        self._id = id

    @property
    def id(self) :
        return self._id

    @id.setter
    def id(self, value) :
        self._id = value

    def _create_xml_obj(self, spec) :
        return spec.NamedValueWithType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(NamedValue, self).dump_xml(spec)

        xml_obj.input_id = self._id

        return xml_obj

    def _dump_dict(self, supplied_fields):
        #Ensures we only have accepted base values
        base_fields = supplied_fields.intersection(self._get_base_fields())
        named_dict = super(NamedValue, self)._dump_dict(base_fields)

        if 'id' in supplied_fields:
            named_dict['id'] = self._id

        return named_dict

    def dump_dict(self, *args):

        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(",".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.NamedValueWithType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        value = cls(value=xml_obj.value(),
                    encoding=xml_obj.encoding,
                    handling=xml_obj.type,
                    id=xml_obj.input_id)

        return value


class BaseInput(NamedValue) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None) :
        super(BaseInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id)
        self._delay_before = None
        self._delay_after = None

        if delay_before is not None :
            self._delay_before = int(delay_before)

        if delay_after is not None :
            self._delay_after = int(delay_after)

    @property
    def type(self) :
        raise MetadataError('Input type not implemented.')

    @property
    def delay_before(self) :
        return self._delay_before

    @delay_before.setter
    def delay_before(self, value) :
        if value is not None :
            self._delay_before = int(value)
        else :
            self._delay_before = None

    @property
    def delay_after(self) :
        return self._delay_after

    @delay_after.setter
    def delay_after(self, value) :
        if value is not None :
            self._delay_after = int(value)
        else :
            self._delay_after = None

    def _dump_process(self, xml_obj_input, spec) :
        xml_obj = spec.process()
        xml_obj.append(xml_obj_input)

        xml_obj.delay_before = self._delay_before
        xml_obj.delay_after = self._delay_after

        return xml_obj

    @classmethod
    def load_input(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ProcessType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = None

        if xml_obj.script is not None :
            input = ScriptInput.load_xml(xml_obj.script, spec)
        elif xml_obj.environment_variable is not None :
            input = EnvironmentVariableInput.load_xml(xml_obj.environment_variable, spec)
        elif xml_obj.file is not None :
            input = FileContentInput.load_xml(xml_obj.file, spec)
        elif xml_obj.database is not None :
            input = DatabaseInput.load_xml(xml_obj.database, spec)
        elif xml_obj.socket is not None :
            input = SocketInput.load_xml(xml_obj.socket, spec)
        else :
            raise MetadataError('Invalid process element.  No input specified.')

        input.delay_before = xml_obj.delay_before
        input.delay_after = xml_obj.delay_after

        return input


    def _dump_dict(self, supplied_fields):
        base_dict = super(BaseInput, self)._dump_dict(supplied_fields)

        if 'delay_before' in supplied_fields:
            base_dict['delay_before'] = self._delay_before

        if 'delay_after' in supplied_fields:
            base_dict['delay_after'] = self._delay_after

        if 'type' in supplied_fields:
            base_dict['type'] = (getattr(self, 'type')).value \
                                if hasattr(self, 'type') else None

        return base_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(",".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

class ScriptInput(BaseInput) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None,
                 background=False) :
        super(ScriptInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id,
            delay_before=delay_before,
            delay_after=delay_after)
        self._background = background

    @property
    def type(self) :
        return InputType.script

    def _create_xml_obj(self, spec) :
        return spec.ScriptType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(ScriptInput, self).dump_xml(spec)
        xml_obj.background = self._background
        xml_obj = self._dump_process(xml_obj, spec)

        return xml_obj

    @property
    def background(self) :
        return self._background

    @background.setter
    def background(self, value) :
        if value is not None :
            self._background = bool(value)
        else :
            self._background = None

    def _dump_dict(self, supplied_fields):
        script_dict = super(ScriptInput, self)._dump_dict(supplied_fields)

        script_dict['background'] = self._background

        return script_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'type',
                           'background'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(",".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ScriptType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(ScriptInput, cls).load_xml(xml_obj, spec)
        input.background = xml_obj.background

        return input


class EnvironmentVariableInput(BaseInput) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None,
                 key=None) :
        super(EnvironmentVariableInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id,
            delay_before=delay_before,
            delay_after=delay_after)
        self._key = key

    @property
    def type(self) :
        return InputType.environment_variable

    @property
    def key(self) :
        return self._key

    @key.setter
    def key(self, value) :
        self._key = value

    def _create_xml_obj(self, spec) :
        return spec.EnvironmentVariableType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(EnvironmentVariableInput, self).dump_xml(spec)

        xml_obj.key = self._key

        xml_obj = self._dump_process(xml_obj, spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        env_dict = super(EnvironmentVariableInput, self)._dump_dict(supplied_fields)

        if 'key' in supplied_fields:
            env_dict['key'] = self._key

        if 'type' in supplied_fields:
            env_dict['type'] = self.type.value

        return env_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'key',
                           'type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.EnvironmentVariableType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(EnvironmentVariableInput, cls).load_xml(xml_obj, spec)

        input.key = xml_obj.key

        return input


class FileContentInput(BaseInput) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None,
                 path=None) :
        super(FileContentInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id,
            delay_before=delay_before,
            delay_after=delay_after)
        self._path = path

    @property
    def type(self) :
        return InputType.file_content

    @property
    def path(self) :
        return self._path

    @path.setter
    def path(self, value) :
        self._path = value

    def _create_xml_obj(self, spec) :
        return spec.FileContentsType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(FileContentInput, self).dump_xml(spec)

        xml_obj.path = self._path

        xml_obj = self._dump_process(xml_obj, spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        env_dict = super(FileContentInput, self)._dump_dict(supplied_fields)

        if 'path' in supplied_fields:
            env_dict['path'] = self._path

        if 'type' in supplied_fields:
            env_dict['type'] = self.type.value

        return env_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'path',
                           'type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.FileContentsType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(FileContentInput, cls).load_xml(xml_obj, spec)

        input.path = xml_obj.path

        return input


class SocketInput(BaseInput) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None,
                 address=None,
                 port=None) :
        super(SocketInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id,
            delay_before=delay_before,
            delay_after=delay_after)
        self._address = address
        self._port = None

        if port is not None :
            self._port = int(port)

    @property
    def type(self) :
        return InputType.socket

    @property
    def address(self) :
        return self._address

    @address.setter
    def address(self, value) :
        self._address = value

    @property
    def port(self) :
        return self._port

    @port.setter
    def port(self, value) :
        if value is not None :
            self._port = int(value)
        else :
            self._port = None

    def _create_xml_obj(self, spec) :
        return spec.SocketType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(SocketInput, self).dump_xml(spec)

        xml_obj.address = self._address
        xml_obj.port = self._port

        xml_obj = self._dump_process(xml_obj, spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        env_dict = super(SocketInput, self)._dump_dict(supplied_fields)

        if 'port' in supplied_fields:
            env_dict['port'] = self._port

        if 'address' in supplied_fields:
            env_dict['address'] = self._address

        if 'type' in supplied_fields:
            env_dict['type'] = self.type.value

        return env_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'port',
                           'address',
                           'type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.SocketType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(SocketInput, cls).load_xml(xml_obj, spec)

        input.address = xml_obj.address
        input.port = xml_obj.port

        return input


class DatabaseInput(BaseInput) :
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT',
                 id=None,
                 delay_before=None,
                 delay_after=None,
                 server=None,
                 port=None,
                 database_type=None,
                 database_name=None) :
        super(DatabaseInput, self).__init__(value=value,
            encoding=encoding,
            handling=handling,
            id=id,
            delay_before=delay_before,
            delay_after=delay_after)
        self._server = server
        self._port = None
        self._database_type = self.parse_database_type(database_type)
        self._database_name = database_name

        if port is not None :
            self._port = int(port)

    @property
    def type(self) :
        return InputType.database

    @property
    def server(self) :
        return self._server

    @server.setter
    def server(self, value) :
        self._server = value

    @property
    def port(self) :
        return self._port

    @port.setter
    def port(self, value) :
        if value is not None :
            self._port = int(value)
        else :
            self._port = None

    @property
    def database_type(self) :
        return self._database_type

    @database_type.setter
    def database_type(self, value) :
        self._database_type = self.parse_database_type(value)

    @property
    def database_name(self) :
        return self._database_name

    @database_name.setter
    def database_name(self, value) :
        self._database_name = value

    def _create_xml_obj(self, spec) :
        return spec.DatabaseContentType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(DatabaseInput, self).dump_xml(spec)

        xml_obj.server = self._server
        xml_obj.port = self._port
        xml_obj.database_type = self._database_type.value if self._database_type is not None else None
        xml_obj.database_name = self._database_name

        xml_obj = self._dump_process(xml_obj, spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        env_dict = super(DatabaseInput, self)._dump_dict(supplied_fields)

        if 'port' in supplied_fields:
            env_dict['port'] = self._port

        if 'server' in supplied_fields:
            env_dict['server'] = self._server

        if 'database_name' in supplied_fields:
            env_dict['database_name'] = self._database_name

        if 'database_type' in supplied_fields:
            env_dict['database_type'] = self._database_type.value \
                                        if self._database_type is not None \
                                        else None

        if 'type' in supplied_fields:
            env_dict['type'] = self.type.value

        return env_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                           'encoding',
                           'handling',
                           'id',
                           'delay_before',
                           'delay_after',
                           'port',
                           'server',
                           'database_name',
                           'database_type',
                           'type'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_database_type(cls, database_type) :
        if database_type is None :
            return None
        elif isinstance(database_type, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.DatabaseType[database_type]
            except ValueError :
                raise MetadataError('Invalid value handling type "{0:s}".'.format(database_type))
        else :
            return database_type

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.DatabaseContentType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(DatabaseInput, cls).load_xml(xml_obj, spec)

        input.server = xml_obj.server
        input.port = xml_obj.port
        input.database_type = xml_obj.database_type
        input.database_name = xml_obj.database_name

        return input

class OutputCheck(MetadataObject) :
    def __init__(self,
                 name=None,
                 check=None,
                 rescorable=None) :
        self._name = name
        self._check = self.parse_check(check)
        self._rescorable = rescorable

    @property
    def name(self) :
        return self._name

    @name.setter
    def name(self, value) :
        self._name = value

    @property
    def check(self) :
        return self._check

    @check.setter
    def check(self, value) :
        self._check = self.parse_check(value)

    @property
    def rescorable(self) :
        return self._rescorable

    @rescorable.setter
    def rescorable(self, value) :
        self._rescorable = value

    def dump_xml(self, spec, use_type=False) :
        xml_obj = self._create_xml_obj(spec, use_type)

        xml_obj.name = self._name
        xml_obj.check_type = self._check.value if self._check is not None else None
        xml_obj.rescorable = self._rescorable

        return xml_obj

    def _dump_dict(self, supplied_fields):
        output_dict = dict()

        if 'name' in supplied_fields:
            output_dict['name'] = self._name

        if 'check' in supplied_fields:
            output_dict['check'] = self._check.value \
                                   if self._check is not None \
                                   else None
        if 'rescorable' in supplied_fields:
            output_dict['rescorable'] = self._rescorable

        return output_dict

    def dump_dict(self, *args):
        valid_fields = set(['name',
                            'check',
                            'rescorable'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields specified: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_check(cls, check) :
        raise MetadataError('parse_check method not implemented for "{0:s}".'.format(cls.__name__))

    @classmethod
    def load_check(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.SimpleOutputCheckType) and not isinstance(xml_obj, spec.CompareOutputCheckType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        check = None
        if isinstance(xml_obj, spec.SimpleOutputCheckType):
            check = SimpleOutputCheck.load_xml(xml_obj, spec)
        elif isinstance(xml_obj, spec.CompareOutputCheckType):
            check = CompareOutputCheck.load_xml(xml_obj, spec)

        return check


class CompareOutputCheck(OutputCheck) :
    def __init__(self,
                 name=None,
                 check=None,
                 rescorable=None,
                 actual=None,
                 expected=None) :

        super(CompareOutputCheck, self).__init__(name=name,
            check=check,
            rescorable=rescorable)

        if actual is not None and isinstance(actual, Actual):
            self._actual = actual
        elif actual is not None:
            raise MetadataError('Invalid actual type "{0:s}".'.format(actual))

        if expected is not None and isinstance(expected, Expected):
            self._expected = expected
        elif expected is not None:
            raise MetadataError('Invalid expected type "{0:s}".'.format(expected))

    @property
    def actual(self) :
        return self._actual

    @actual.setter
    def actual(self, value) :
        self._actual = value

    @property
    def expected(self) :
        return self._expected

    @expected.setter
    def expected(self, value) :
        self._expected = value

    def _create_xml_obj(self, spec, use_type=False) :
        if use_type:
            return spec.CompareOutputCheckType()
        else:
            return spec.compare_check()

    def dump_xml(self, spec, use_type=False) :
        xml_obj = super(CompareOutputCheck, self).dump_xml(spec)

        xml_obj.actual = self._actual.dump_xml(spec)
        xml_obj.expected = self._expected.dump_xml(spec)

        return xml_obj

    def _dump_dict(self, supplied_fields):
        compare_dict = super(CompareOutputCheck, self)._dump_dict(supplied_fields)

        if 'actual' in supplied_fields:
            compare_dict['actual'] = self._actual.dump_dict() \
                                     if self._actual is not None \
                                     else None

        if 'expected' in supplied_fields:
            compare_dict['expected'] = self._expected.dump_dict() \
                                       if self._expected is not None \
                                       else None

        return compare_dict

    def dump_dict(self, *args):
        valid_fields = set(['name',
                            'check',
                            'rescorable',
                            'actual',
                            'expected'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields specified: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_check(cls, check) :
        if check is None :
            return None
        elif isinstance(check, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.CompareCheckType[check]
            except ValueError :
                raise MetadataError('Invalid compare check type "{0:s}".'.format(check))
        else :
            return check

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.CompareOutputCheckType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))


        oc = CompareOutputCheck(name=xml_obj.name,
                           check=xml_obj.check_type,
                           rescorable=xml_obj.rescorable,
                           actual=Actual.load_xml(xml_obj.actual, spec),
                           expected=Expected.load_xml(xml_obj.expected, spec))

        return oc


class SimpleOutputCheck(OutputCheck):
    def __init__(self,
                 name=None,
                 check=None,
                 rescorable=None,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT') :

        super(SimpleOutputCheck, self).__init__(name=name,
            check=check,
            rescorable=rescorable)
        self._value = value
        self._encoding = self.parse_encoding(encoding)
        self._handling = self.parse_handling(handling)

    @property
    def value(self) :
        return self._value

    @value.setter
    def value(self, value) :
        self._value = value

    @property
    def encoding(self) :
        return self._encoding

    @encoding.setter
    def encoding(self, value) :
        self._encoding = self.parse_encoding(value)

    @property
    def handling(self) :
        return self._handling

    @handling.setter
    def handling(self, value) :
        self._handling = self.parse_handling(value)

    @classmethod
    def parse_encoding(cls, encoding) :
        if encoding is None :
            return None
        elif isinstance(encoding, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.EncodingType[encoding]
            except ValueError :
                raise MetadataError('Invalid encoding "{0:s}".'.format(encoding))
        else :
            return encoding

    @classmethod
    def parse_handling(cls, handling) :
        if handling is None :
            return None
        elif isinstance(handling, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ValueType[handling]
            except ValueError :
                raise MetadataError('Invalid value handling type "{0:s}".'.format(handling))
        else :
            return handling

    @classmethod
    def parse_check(cls, check) :
        if check is None :
            return None
        elif isinstance(check, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.SimpleCheckType[check]
            except ValueError :
                raise MetadataError('Invalid simple check type "{0:s}".'.format(check))
        else :
            return check

    def _create_xml_obj(self, spec, use_type=False) :
        if use_type:
            return spec.SimpleOutputCheckType(self._value)
        else:
            return spec.simple_check(self._value)

    def dump_xml(self, spec, use_type=False) :

        xml_obj = super(SimpleOutputCheck, self).dump_xml(spec, use_type)
        xml_obj.encoding = self._encoding.value
        xml_obj.type = self._handling.value

        return xml_obj

    def _dump_dict(self, supplied_fields):
        simple_dict = super(SimpleOutputCheck, self)._dump_dict(supplied_fields)

        if 'value' in supplied_fields:
            simple_dict['value'] = self._value

        if 'encoding' in supplied_fields:
            simple_dict['encoding'] = self._encoding.value \
                                       if self._encoding is not None \
                                       else None

        if 'handling' in supplied_fields:
            simple_dict['handling'] = self._handling.value \
                                       if self._handling is not None \
                                       else None

        return simple_dict

    def dump_dict(self, *args):
        valid_fields = set(['name',
                            'check',
                            'rescorable',
                            'value',
                            'encoding',
                            'handling'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields specified: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.SimpleOutputCheckType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        oc =  oc = SimpleOutputCheck(name=xml_obj.name,
                           check=xml_obj.check_type,
                           rescorable=xml_obj.rescorable,
                           value=xml_obj.value(),
                           encoding=cls.parse_encoding(xml_obj.encoding),
                           handling=cls.parse_handling(xml_obj.type))

        return oc

class Actual(MetadataObject):
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 output=None,
                 input_id=None) :

        self._value = value
        self._encoding = self.parse_encoding(encoding)
        self._output = self.parse_output(output)
        self._input_id = input_id

    @property
    def value(self) :
        return self._value

    @value.setter
    def value(self, value) :
        self._value = value

    @property
    def encoding(self) :
        return self._encoding

    @encoding.setter
    def encoding(self, value) :
        self._encoding = self.parse_encoding(value)


    @property
    def output(self) :
        return self._output

    @output.setter
    def output(self, value) :
        self._output = self.parse_output(value)

    @property
    def input_id(self) :
        return self._input_id

    @input_id.setter
    def input_id(self, value) :
        self._input_id = value

    def _create_xml_obj(self, spec) :
        return spec.ActualOutputType(self._value)

    def dump_xml(self, spec) :
        xml_obj = self._create_xml_obj(spec)

        xml_obj.encoding = self._encoding.value if self._encoding is not None else None
        xml_obj.output_type = self._output.value if self._output is not None else None
        xml_obj.input_id_ref = self._input_id


        return xml_obj

    @classmethod
    def parse_output(cls, output) :
        if output is None :
            return None
        elif isinstance(output, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.OutputType[output]
            except ValueError :
                raise MetadataError('Invalid output type "{0:s}".'.format(output))
        else :
            return output


    @classmethod
    def parse_encoding(cls, encoding) :
        if encoding is None :
            return None
        elif isinstance(encoding, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.EncodingType[encoding]
            except ValueError :
                raise MetadataError('Invalid encoding "{0:s}".'.format(encoding))
        else :
            return encoding

    def _dump_dict(self, supplied_fields):
        actual_dict = dict()

        for field in supplied_fields:
            if field == 'encoding':
                actual_dict[field]= self._encoding.value \
                                    if self._encoding is not None \
                                    else None
            elif field == 'output':
                actual_dict[field]= self._output.value \
                                    if self._output is not None \
                                    else None
            else:
                actual_dict[field] = getattr(self, field)
        return actual_dict

    def dump_dict(self, *args):
        valid_fields = set(['value',
                            'encoding',
                            'output',
                            'input_id'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields specified: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ActualOutputType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))


        value = xml_obj.value()
        output = xml_obj.output_type
        encoding = xml_obj.encoding

        input_id = xml_obj.input_id_ref

        return Actual(value=value,
                      output=output,
                      encoding=encoding,
                      input_id=input_id)


class Expected(SimpleValue):
    def __init__(self,
                 value=None,
                 encoding='STRING',
                 handling='USE_TEXT') :
        super(Expected, self).__init__(value=value,
            encoding=encoding,
            handling=handling)


    def _create_xml_obj(self, spec) :
        return spec.ExpectedOutputType(self._value)

    def dump_xml(self, spec) :
        xml_obj = super(Expected, self).dump_xml(spec)

        return xml_obj

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ExpectedOutputType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        input = super(Expected, cls).load_xml(xml_obj, spec)

        return input


class ExecutionGroup(MetadataObject) :
    def __init__(self,
                 scheme='SEQUENCE',
                 inputs=None) :
        self._scheme = self.parse_scheme(scheme)
        self._inputs = [ ]

        if inputs is not None and\
                isinstance(inputs, collections.Sequence) :
            for input in inputs :
                if not isinstance(input, BaseInput) and\
                        not isinstance(input, ExecutionGroup) :
                    raise MetadataError('Invalid input type "{0:s}".'.format(type(input)))
                self._inputs.append(input)

    @property
    def scheme(self) :
        return self._scheme

    @scheme.setter
    def scheme(self, value) :
        self._scheme = self.parse_scheme(value)

    @property
    def inputs(self) :
        return self._inputs

    @inputs.setter
    def inputs(self, value) :
        del self._inputs[:]
        if value is not None and\
                isinstance(value, collections.Sequence) :
            for input in value :
                if not isinstance(input, BaseInput) and\
                        not isinstance(input, ExecutionGroup) :
                    raise MetadataError('Invalid input type "{0:s}".'.format(type(input)))
                self._inputs.append(input)

    @property
    def has_inputs(self) :
        return len(self._inputs) != 0

    def dump_xml(self, spec, use_type=False) :
        xml_obj = None
        if use_type :
            xml_obj = spec.ExecutionGroupType()
        else :
            xml_obj = spec.process_group()

        xml_obj.scheme = self._scheme.value if self._scheme is not None else None

        for input in self._inputs :
            xml_obj.processes.append(input.dump_xml(spec))

        return xml_obj

    @classmethod
    def parse_scheme(cls, scheme) :
        if scheme is None :
            return None
        elif isinstance(scheme, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ExecutionSchemeType[scheme]
            except ValueError :
                raise MetadataError('Invalid execution scheme "{0:s}".'.format(scheme))
        else :
            return scheme


    def _dump_dict(self, supplied_fields):
        execution_dict = dict()

        if 'inputs' in supplied_fields:
            inputs = list()
            if self._inputs is not None and \
               isinstance(self._inputs, collections.Sequence):
                for input in self._inputs:
                    if not isinstance(input, BaseInput) and \
                       not isinstance(input, ExecutionGroup):
                        raise MetadataError("Invalid input type: {0:s}".format(type(input)))
                    inputs.append(input.dump_dict())
            execution_dict['inputs'] = inputs

        if 'scheme' in supplied_fields:
            execution_dict['scheme'] = self._scheme.value \
                                       if self._scheme is not None \
                                       else None

        return execution_dict

    def dump_dict(self, *args):
        valid_fields = set(['scheme',
                            'inputs'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields specified: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.ExecutionGroupType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        inputs = None
        if len(xml_obj.orderedContent()) != 0 :
            inputs = [ ]
            for item in xml_obj.orderedContent() :
                if isinstance(item.value, spec.ProcessType) :
                    inputs.append(BaseInput.load_input(item.value, spec))
                else :
                    inputs.append(ExecutionGroup.load_xml(item.value, spec))


        group = cls(scheme=xml_obj.scheme,
                    inputs=inputs)

        return group


class IOPair(MetadataObject) :
    def __init__(self,
                 name=None,
                 category=None,
                 timeout=300,
                 reset='NONE',
                 description=None,
                 derived_from=None,
                 technical_impacts=None,
                 run_command=None,
                 run_command_merge=True,
                 run_command_encoding='STRING',
                 pre_processes=None,
                 co_processes=None,
                 post_processes=None,
                 scoring_checks=None,
                 scoring_formulas=None,
                 default_scoring_formula=None,
                 resource_limits=None):

        self._name = name
        self._description = description
        self._derived_from = derived_from
        self._category = self.parse_category(category)
        self._reset = self.parse_reset(reset)
        self._timeout = 300
        self._technical_impacts = [ ]
        self._run_command = run_command
        self._run_command_encoding = SimpleValue.parse_encoding(run_command_encoding)
        self._run_command_merge = True
        self._pre_processes = None
        self._co_processes = None
        self._post_processes = None
        self._scoring_checks = [ ]
        self._scoring_formulas = collections.OrderedDict()
        self._default_scoring_formula_id = default_scoring_formula
        self._resource_limits = collections.OrderedDict()

        # valid provided pre_processes or set default
        if pre_processes is not None :
            if not isinstance(pre_processes, ExecutionGroup) :
                raise MetadataError('Invalid pre_process object "{0:s}"'.format(type(pre_processes)))
            else :
                self._pre_processes = pre_processes
        else :
            self._pre_processes = ExecutionGroup()

        # valid provided co_processes or set default
        if co_processes is not None :
            if not isinstance(co_processes, ExecutionGroup) :
                raise MetadataError('Invalid co_process object "{0:s}"'.format(type(co_processes)))
            else :
                self._co_processes = co_processes
        else :
            self._co_processes = ExecutionGroup()

        # valid provided post_processes or set default
        if post_processes is not None :
            if not isinstance(post_processes, ExecutionGroup) :
                raise MetadataError('Invalid post_process object "{0:s}"'.format(type(post_processes)))
            else :
                self._post_processes = post_processes
        else :
            self._post_processes = ExecutionGroup()

        if timeout is not None :
            self._timeout = int(timeout)

        if run_command_merge is not None :
            self._run_command_merge = bool(run_command_merge)

        if scoring_checks is not None and\
                isinstance(scoring_checks, collections.Sequence) :
            for check in scoring_checks :
                if not isinstance(check, SimpleOutputCheck) and not isinstance(check, CompareOutputCheck):
                    raise MetadataError('Invalid scoring check type "{0:s}".'.format(type(check)))
                self._scoring_checks.append(check)

        if scoring_formulas is not None and\
                isinstance(scoring_formulas, collections.Mapping) :
            self._scoring_formulas.update(scoring_formulas)

        if technical_impacts is not None and\
                isinstance(technical_impacts, collections.Iterable) :
            for impact in technical_impacts :
                self._technical_impacts.append(self.parse_technical_impact(impact))

        if resource_limits is not None and\
                isinstance(resource_limits, collections.Mapping) :
            for rlimit_type, rlimit_value in resource_limits.iteritems() :
                self._resource_limits[self.parse_resource_limit(rlimit_type)] = rlimit_value

    def __str__(self) :
        return 'IO Pair: {0:s} ({1:s})'.format(self._name, self._category.value if self._category is not None else 'UNKNOWN')

    @property
    def name(self) :
        return self._name

    @name.setter
    def name(self, value) :
        self._name = value

    @property
    def description(self) :
        return self._description

    @description.setter
    def description(self, value) :
        self._description = value

    @property
    def derived_from(self) :
        return self._derived_from

    @derived_from.setter
    def derived_from(self, value) :
        self._derived_from = value

    @property
    def category(self) :
        return self._category

    @category.setter
    def category(self, value) :
        self._category = self.parse_category(value)

    @property
    def reset(self) :
        return self._reset

    @reset.setter
    def reset(self, value) :
        self._reset = self.parse_reset(value)

    @property
    def timeout(self) :
        return self._timeout

    @timeout.setter
    def timeout(self, value) :
        if value is not None :
            self._timeout = int(value)
        else :
            self._timeout = None

    @property
    def technical_impacts(self) :
        return self._technical_impacts

    @technical_impacts.setter
    def technical_impacts(self, value) :
        del self._technical_impacts[:]
        if value is not None :
            for item in value :
                self._technical_impacts.append(self.parse_technical_impact(item))

    @property
    def run_command(self) :
        return self._run_command

    @run_command.setter
    def run_command(self, value) :
        self._run_command = value

    @property
    def run_command_merge(self) :
        return self._run_command_merge

    @run_command_merge.setter
    def run_command_merge(self, value) :
        if value is None :
            value = True
        self._run_command_merge = bool(value)

    @property
    def run_command_encoding(self):
        return self._run_command_encoding

    @run_command_encoding.setter
    def run_command_encoding(self, value):
        self._run_command_encoding = SimpleValue.parse_encoding(value)

    @property
    def pre_processes(self) :
        return self._pre_processes

    @property
    def co_processes(self) :
        return self._co_processes

    @property
    def post_processes(self) :
        return self._post_processes

    @property
    def scoring_checks(self) :
        return self._scoring_checks

    @scoring_checks.setter
    def scoring_checks(self, value) :
        del self._scoring_checks[:]
        if value is not None :
            for item in value :
                if not isinstance(item, OutputCheck) :
                    raise MetadataError('Invalid scoring check type "{0:s}".'.format(type(value)))
                self._scoring_checks.append(item)

    @property
    def scoring_formulas(self) :
        return self._scoring_formulas

    @scoring_formulas.setter
    def scoring_formulas(self, value) :
        self._scoring_formulas.clear()
        if value is not None :
            if isinstance(value, collections.Mapping) :
                self._scoring_formulas.update(value)

    @property
    def default_scoring_formula_id(self) :
        return self._default_scoring_formula_id

    @default_scoring_formula_id.setter
    def default_scoring_formula_id(self, value) :
        self._default_scoring_formula_id = value

    @property
    def default_scoring_formula(self) :
        if self._default_scoring_formula_id is None :
            return None
        if self._default_scoring_formula_id not in self._scoring_formulas :
            return None
        return self._scoring_formulas[self._default_scoring_formula_id]

    @property
    def resource_limits(self) :
        return self._resource_limits

    @resource_limits.setter
    def resource_limits(self, value) :
        self._resource_limits.clear()
        if value is not None :
            if not isinstance(value, collections.Mapping) :
                raise MetadataError('Invalid resource limits "{0:s}".'.format(type(value)))
            for rlimit_type, rlimit_value in value.iteritems() :
                self._resource_limits[self.parse_resource_limit(rlimit_type)] = rlimit_value

    @property
    def has_resource_limits(self) :
        return len(self._resource_limits) != 0

    def dump_xml(self, spec) :
        xml_obj = spec.IOPairType()

        xml_obj.name = self._name
        xml_obj.type = self._category.value if self._category is not None else None
        xml_obj.timeout = self._timeout
        xml_obj.reset_scheme = self._reset.value if self._reset is not None else None
        xml_obj.derived_from = self._derived_from

        for impact in self._technical_impacts :
            if impact is not None :
                xml_obj.technical_impact.append(impact.value)

        xml_obj.description = self._description

        if self._pre_processes.has_inputs :
            xml_obj.pre_processes = self._pre_processes.dump_xml(spec, use_type=True)

        if self._co_processes.has_inputs :
            xml_obj.co_processes = self._co_processes.dump_xml(spec, use_type=True)

        if self._post_processes.has_inputs :
            xml_obj.post_processes = self._post_processes.dump_xml(spec, use_type=True)

        if len(self._scoring_formulas) != 0 :
            xml_obj_formulas = spec.ScoringFormulaType()

            xml_obj_formulas.default = self._default_scoring_formula_id

            for formula_id, formula_value in self._scoring_formulas.items():
                xml_obj_formula = spec.FormulaType(formula_value)
                xml_obj_formula.name = formula_id
                xml_obj_formulas.formula.append(xml_obj_formula)

            xml_obj.scoring_formula = xml_obj_formulas

        if len(self._scoring_checks) != 0 :
            xml_obj_checks = spec.OutputCheckGroupType()

            for check in self._scoring_checks :
                xml_obj_checks.output_check.append(check.dump_xml(spec))

            xml_obj.output_checks = xml_obj_checks

        if len(self._resource_limits) != 0 :
            xml_obj_rlimits = spec.ResourceLimitsGroupType()

            for rlimit_type, rlimit_value in self._resource_limits.iteritems() :
                xml_obj_rlimit = spec.ResourceLimitKeyValuePairType(rlimit_value)
                xml_obj_rlimit.type = rlimit_type.value
                xml_obj_rlimits.limit.append(xml_obj_rlimit)

            xml_obj.resource_limits = xml_obj_rlimits

        xml_obj_command = spec.ValueWithPrependType(self._run_command)
        xml_obj_command.preprend_runcommand = self._run_command_merge
        xml_obj_command.type = 'USE_TEXT'
        xml_obj_command.encoding = self._run_command_encoding.value
        xml_obj.run_command = xml_obj_command

        return xml_obj

    def _dump_dict(self, supplied_fields):
        io_dict = dict()

        for field in supplied_fields:
            if field=="pre_processes":
                if self._pre_processes is not None:
                    if not isinstance(self._pre_processes, ExecutionGroup):
                        raise MetadataError("Invalid Pre Processes type: {0:s}".format(type(self._pre_processes)))
                    io_dict[field] = self._pre_processes.dump_dict()
                else:
                    io_dict[field] = None

            elif field=="co_processes":
                if self._co_processes is not None:
                    if not isinstance(self._co_processes, ExecutionGroup):
                        raise MetadataError("Invalid Co Processes type: {0:s}".format(type(self._co_processes)))
                    io_dict[field] = self._co_processes.dump_dict()
                else:
                    io_dict[field] = None

            elif field == 'post_processes':
                if self._post_processes is not None:
                    if not isinstance(self._post_processes, ExecutionGroup):
                        raise MetadataError("invalid Post Process type: {0:s}".format(type(self._post_processes)))
                    io_dict[field] = self._post_processes.dump_dict()
                else:
                    io_dict[field] = None

            elif field == 'technical_impacts':
                technical_impacts = []
                if self._technical_impacts is not None and \
                   isinstance(self._technical_impacts, collections.Iterable):
                    for impact in self._technical_impacts:
                        technical_impacts.append(impact.value if impact is not None else None)

                io_dict[field] = technical_impacts
            elif field == 'scoring_checks':
                scoring_checks = list()
                if self._scoring_checks is not None and \
                   isinstance(self._scoring_checks, collections.Sequence):
                    for check in self._scoring_checks:
                        if not isinstance(check, SimpleOutputCheck) and not isinstance(check, CompareOutputCheck):
                            raise MetadataError('Invalid scoring check type "{0:s}".'.format(type(check)))
                        scoring_checks.append(check.dump_dict())
                io_dict[field] = scoring_checks
            elif field == "resource_limits":
                resource_limits = collections.OrderedDict()
                if self._resource_limits is not None:
                    for key, value in self._resource_limits.iteritems():
                        resource_limits[key.value] = value
                else:
                    resource_limits = None

                io_dict[field] = resource_limits
            elif field == "category":
                io_dict[field] = self._category.value \
                                 if self._category is not None \
                                 else None
            elif field == "reset":
                io_dict[field] = self._reset.value \
                                 if self._reset is not None \
                                 else None
            elif field == "run_command_encoding":
                io_dict[field] = self._run_command_encoding.value \
                                 if self._run_command_encoding is not None \
                                 else None
            else:
                io_dict[field] = getattr(self, field)

        return io_dict

    def dump_dict(self, *args):
        valid_fields=set(['name',
                          'category',
                          'timeout',
                          'reset',
                          'description',
                          'derived_from',
                          'technical_impacts',
                          'run_command',
                          'run_command_merge',
                          'run_command_encoding',
                          'pre_processes',
                          'post_processes',
                          'co_processes',
                          'scoring_checks',
                          'scoring_formulas',
                          'default_scoring_formula_id',
                          'resource_limits'])

        supplied_fields = set(args)

        invalid_fields = supplied_fields.difference(valid_fields)

        if len(invalid_fields) > 0:
            raise MetadataError("Invalid fields supplied: {0:s}".format(", ".join(invalid_fields)))

        if len(supplied_fields) > 0:
            return self._dump_dict(supplied_fields)
        else:
            return self._dump_dict(valid_fields)

    @classmethod
    def parse_technical_impact(cls, technical_impact) :
        if technical_impact is None :
            return None
        elif isinstance(technical_impact, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.TechnicalImpactType[technical_impact]
            except ValueError :
                raise MetadataError('Invalid technical impact "{0:s}".'.format(technical_impact))
        else :
            return technical_impact

    @classmethod
    def parse_category(cls, category) :
        if category is None :
            return None
        elif isinstance(category, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.IOPairCategoryType[category]
            except ValueError :
                raise MetadataError('Invalid IO pair category "{0:s}".'.format(category))
        else :
            return category

    @classmethod
    def parse_reset(cls, reset) :
        if reset is None :
            return None
        elif isinstance(reset, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ResetType[reset]
            except ValueError :
                raise MetadataError('Invalid reset scheme "{0:s}".'.format(reset))
        else :
            return reset

    @classmethod
    def parse_resource_limit(cls, resource_limit) :
        if resource_limit is None :
            return None
        elif isinstance(resource_limit, basestring) :
            try :
                _enums = cls._load_local_module('enums')
                return _enums.ResourceLimitType[resource_limit]
            except ValueError :
                raise MetadataError('Invalid resource limit type "{0:s}".'.format(resource_limit))
        else :
            return resource_limit

    @classmethod
    def load_xml(cls, xml_obj, spec) :
        if xml_obj is None :
            return None
        elif not isinstance(xml_obj, spec.IOPairType) :
            raise MetadataError('Attempt to parse an unexpected element type "{0:s}".'.format(type(xml_obj)))

        technical_impacts = None
        run_command = None
        run_command_merge = None
        scoring_checks = None
        scoring_formulas = None
        default_scoring_formula = None
        resource_limits = None

        if len(xml_obj.technical_impact) != 0 :
            technical_impacts = []
            for impact in xml_obj.technical_impact :
                technical_impacts.append(impact)

        if xml_obj.run_command is not None :
            run_command_merge = xml_obj.run_command.preprend_runcommand
            run_command_encoding = xml_obj.run_command.encoding
            run_command = xml_obj.run_command.value()

        if xml_obj.output_checks is not None :
            scoring_checks = [ ]
            for check in xml_obj.output_checks.output_check :
                scoring_checks.append(OutputCheck.load_check(check, spec))

        if xml_obj.scoring_formula is not None :
            default_scoring_formula = xml_obj.scoring_formula.default
            scoring_formulas = collections.OrderedDict()
            if len(xml_obj.orderedContent()) != 0 :
                for content in xml_obj.scoring_formula.orderedContent() :
                    formula = content.value
                    if isinstance(formula, spec.FormulaType) :
                        scoring_formulas[formula.name] = formula.value()
                    else :
                        raise MetadataError('Attempt to parse an unexpected element type in scoring_formulas"{0:s}".'.format(type(formula)))


        if xml_obj.resource_limits is not None :
            resource_limits = collections.OrderedDict()
            for limit in xml_obj.resource_limits.limit :
                resource_limits[limit.type] = limit.value()

        io_pair = cls(name=xml_obj.name,
                      category=xml_obj.type,
                      timeout=xml_obj.timeout,
                      reset=xml_obj.reset_scheme,
                      description=xml_obj.description,
                      derived_from=xml_obj.derived_from,
                      technical_impacts=technical_impacts,
                      run_command=run_command,
                      run_command_merge=run_command_merge,
                      run_command_encoding=run_command_encoding,
                      pre_processes=ExecutionGroup.load_xml(xml_obj.pre_processes, spec),
                      co_processes=ExecutionGroup.load_xml(xml_obj.co_processes, spec),
                      post_processes=ExecutionGroup.load_xml(xml_obj.post_processes, spec),
                      scoring_checks=scoring_checks,
                      scoring_formulas=scoring_formulas,
                      default_scoring_formula=default_scoring_formula,
                      resource_limits=resource_limits)

        return io_pair
