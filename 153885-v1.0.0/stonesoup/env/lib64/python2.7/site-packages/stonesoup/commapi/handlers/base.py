# ------------------------------Copyright-------------------------------------
# NOTICE
# 
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
# 
# Copyright (c) 2013 Ponte Technologies. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

import datetime

try :
    import httplib
except ImportError :
    import hhtp.client as httplib

try :
    from cStringIO import StringIO
except ImportError :
    from StringIO import StringIO

import tornado.web
import simplejson as json
import mimeparse

from lxml import etree

import stonesoup.commapi.utils.xml as ss_comms_xml
from stonesoup.commapi.handlers import ResolvedContentType

class BaseHandler(tornado.web.RequestHandler) :
    def initialize(self, message_queue, json_validator, xml_schema) :
        self.json_validator = json_validator
        self.message_queue = message_queue
        self.xml_schema = xml_schema

    def _resolve_content_type(self, cont_type, cont_subtype) :
        result = None
        
        if cont_type == 'application' :
            if cont_subtype == 'json' :
                result = ResolvedContentType.json
        elif cont_type == 'text' :
            if cont_subtype == 'javascript' :
                result = ResolvedContentType.json
            elif cont_subtype == 'xml' :
                result = ResolvedContentType.xml
        
        return result
    
    def _generate_prefered_response_content_types(self, content_type_resolved) :
        # the order is increased desirability.  thus, later in the 
        # list is preferred.
        content_types_preferred = [ 'text/html',
                                    'text/xml',
                                    'text/javascript',
                                    'application/json' ]
        
        if content_type_resolved == ResolvedContentType.json :
            pass # list is ordered
        # reorder the list to ensure the proper content comes back
        elif content_type_resolved == ResolvedContentType.xml :
            content_types_preferred.remove('text/xml')
            content_types_preferred.append('text/xml')
        else :
            content_types_preferred.remove('text/html')
            content_types_preferred.append('text/html')
        
        return content_types_preferred 
        
    def _parse_content_type(self, content_type) :
        content_charset = 'ISO-8859-1'   # default for HTTP
        content_type_parsed = (None, None, {})
        # parse the mime-type.  here we want the mime type and any charset
        # parameters that may help us choose how to decode.  this returns
        # a tuple of 3 items: (type, subtype, parameters [dict]).  we will
        # always have 3 items, and the optional parameters will just be
        # an empty dictionary.
        # 
        # example: 'application/json;charset=utf-8' becomes tuple
        #             ( 'application', 'json' { 'charset': 'utf-8' } )
        try :
            content_type_parsed = mimeparse.parse_mime_type(content_type)
        except ValueError :
            # failed to parse, use default
            pass
            
        # update the charset with the request, if specified
        if 'charset' in content_type_parsed[2] :
            content_charset = content_type_parsed[2]['charset']
        
        return content_type_parsed[0], content_type_parsed[1], content_charset
        
    def _detect_content_type(self, content_type) :
        content_type_resolved = ResolvedContentType.unsupported
        
        # ensure there is a content-type
        if content_type is None or \
                content_type == '' :
            # send media type not supported error code
            return content_type_resolved, 'ISO-8859-1'
        
        cont_type, cont_subtype, content_charset = self._parse_content_type(content_type)
        
        # handle error parsing content type
        if cont_type is None or cont_subtype is None :
            return content_type_resolved, content_charset
        
        content_type_resolved =\
            self._resolve_content_type(cont_type, cont_subtype)
        
        return content_type_resolved, content_charset
    
    def _xml_parse_string(self, raw_xml, encoding):
        parser = etree.ETCompatXMLParser(encoding=encoding, schema=self.xml_schema,
            ns_clean=True)
        doc = ss_comms_xml.parsexml_(StringIO(raw_xml), parser=parser)
        rootNode = doc.getroot()
        rootTag, rootClass = ss_comms_xml.get_root_tag(rootNode)
        if rootClass is None:
            rootTag = 'log'
            rootClass = ss_comms_xml.supermod.LogMessageType
        rootObj = rootClass.factory()
        rootObj.build(rootNode)
        # Enable Python to collect the space used by the DOM.
        doc = None
        parser = None
        return rootObj
    
    def _write_response_json(self, status_code, result, message, content_type, content_charset='utf-8') :
    
        response_body = { 'result': result,
                          'code': status_code }
                          
        if message is not None :
            response_body['message'] = message
        
        self.set_header('content-type', '{0}; {1}'.format(content_type, content_charset))

        self.write(json.dumps(response_body, encoding=content_charset))
        
        return
    
    def _write_response_xml(self, status_code, result, message, content_type, content_charset='utf-8') :
        response_message = ss_comms_xml.ResponseMessageTypeSub(code=status_code,
            result=result)
            
        if message is not None :
            response_message.message = message
        
        self.set_header('content-type', '{0}; {1}'.format(content_type, content_charset))
        
        buffer = StringIO()
        response_message.export(buffer, 0, name_='response', namespacedef_='xmlns="urn:stonesoup:api:communications"')
        
        self.write(buffer.getvalue())
        
        buffer.close()
        buffer = None
        
        return
    
    def _write_response_html(self, status_code, result, message, content_type, content_charset='utf-8') :
        response_error_message = ''
        if message is not None :
            response_message = '<p>{0:s}</p>'.format(message)
        
        response_body = '''<html>
    <head>
        <title>HTTP {0:d}: {1:s}</title>
    </head>
    <body>
        <h1>ERROR</h1>
        <h2>HTTP {0:d}: {1:s}</h2>
        {2:s}
    </body>
</html>
'''.format(status_code, httplib.responses[status_code], response_message)
        
        self.set_header('content-type', '{0}; {1}'.format(content_type, content_charset))
        
        self.write(response_body.encode(content_charset))
        
        return
    
    def write_error(self, status_code, **kwargs) :
        error_message = kwargs.pop('error_message', None)
        
        # parse the request content type so we can determine how to
        # write the response (content type)
        content_type_resolved = ResolvedContentType.unsupported
        if 'content-type' in self.request.headers :
            content_type_resolved = self._detect_content_type(self.request.headers['content-type'])[0]
        
        # the preferred response type will be ordered based on the
        # request content type
        response_type_preferred = \
            self._generate_prefered_response_content_types(content_type_resolved)
        
        response_type_mime = None
        response_type_resolved = ResolvedContentType.unsupported
        
        # prefer to match response type with Accept header params, but
        # use input content type if header is not provided.
        if 'accept' in self.request.headers :
            try :
                response_type_mime = mimeparse.best_match(response_type_preferred, 
                    self.request.headers['accept'])
            
                # parse the matched response type
                response_type_resolved = self._detect_content_type(response_type_mime)[0]
            except ValueError :
                # on failure to parse mime type, use request content type
                response_type_mime = response_type_preferred[-1]
                response_type_resolved = content_type_resolved
        else :
            # grab the first item, which is what they provided as input (if supported)
            response_type_mime = response_type_preferred[-1]
            response_type_resolved = content_type_resolved
            
        # call handler for mime type
        if response_type_resolved == ResolvedContentType.json :
            self._write_response_json(status_code, 'ERROR', error_message, 
                response_type_mime)
        elif response_type_resolved == ResolvedContentType.xml :
            # generateDS only supports one output encoding
            self._write_response_xml(status_code, 'ERROR', error_message, 
                response_type_mime)
        else :
            self._write_response_html(status_code, 'ERROR', error_message, 
                response_type_mime)
    
    def _write_success(self, status_code, content_type_resolved, message=None) :
        # the preferred response type will be ordered based on the
        # request content type
        if content_type_resolved is None :
            content_type_resolved = ResolvedContentType.unsupported
            if 'content-type' in self.request.headers :
                content_type_resolved = self._detect_content_type(self.request.headers['content-type'])[0]
        
        response_type_preferred = \
            self._generate_prefered_response_content_types(content_type_resolved)
        
        response_type_mime = None
        response_type_resolved = ResolvedContentType.unsupported
        
        # prefer to match response type with Accept header params, but
        # use input content type if header is not provided.
        if 'accept' in self.request.headers :
            try :
                response_type_mime = mimeparse.best_match(response_type_preferred, 
                    self.request.headers['accept'])
            
                # parse the matched response type
                response_type_resolved = self._detect_content_type(response_type_mime)[0]
            except ValueError :
                # on failure to parse mime type, use request content type
                response_type_mime = response_type_preferred[-1]
                response_type_resolved = content_type_resolved
        else :
            # grab the first item, which is what they provided as input (if supported)
            response_type_mime = response_type_preferred[-1]
            response_type_resolved = content_type_resolved
        
        # call handler for mime type
        if response_type_resolved == ResolvedContentType.json :
            self._write_response_json(status_code, 'SUCCESS', message, 
                response_type_mime)
        elif response_type_resolved == ResolvedContentType.xml :
            # generateDS only supports one output encoding
            self._write_response_xml(status_code, 'SUCCESS', message, 
                response_type_mime)
        else :
            self._write_response_html(status_code, 'SUCCESS', message, 
                response_type_mime)
