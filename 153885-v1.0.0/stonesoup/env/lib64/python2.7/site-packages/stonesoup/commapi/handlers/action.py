# ------------------------------Copyright-------------------------------------
# NOTICE
# 
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
# 
# Copyright (c) 2013 Ponte Technologies. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

import datetime

import simplejson as json
import jsonschema
import pytz

from lxml import etree

import stonesoup.commapi.utils.xml as ss_comms_xml
from stonesoup.commapi.handlers import ResolvedContentType
from stonesoup.commapi.handlers import BaseHandler

class ActionHandler(BaseHandler) :
    def initialize(self, message_queue, json_validator, xml_schema) :
        BaseHandler.initialize(self, message_queue, json_validator, xml_schema)
        
    def get(self) :
        # gets are not supported
        self.send_error(status_code=405, 
            error_message='Action messages may not be retrieved via this API.')
    
    def post(self) :
        action_message = None
        received_timestamp = datetime.datetime.now(pytz.timezone('US/Eastern'))
        content_type, content_charset =\
            self._detect_content_type(self.request.headers['content-type'])
        host = self.request.host
        # ensure content type is supported
        if content_type == ResolvedContentType.unsupported :
            # send media type not supported error code
            self.send_error(status_code=415, 
                error_message='Content type or character encoding \'{0}\' not supported.'.format(self.request.headers['content-type']))
            return
        
        # switch on the content type
        if content_type == ResolvedContentType.json :
            raw_data = None
            try :
                # load the JSON data and validate against the schema
                raw_data = json.loads(self.request.body, content_charset)
            except json.JSONDecodeError, err_json_parse :
                self.send_error(status_code=400, 
                    error_message="Json failure to parse error: %s" %(err_json_parse.msg))
                return
            
            try :
                self.json_validator.validate(raw_data)
            except jsonschema.ValidationError, err_json_validation :
                self.send_error(status_code=400, 
                    error_message="Json failure to validate to schema: %s" %(err_json_validation.message))
                return
            
            # action messages include optional weakness and impact messages
            # thus, they must also be constructed at this point
            weakness_message = None
            impact_message = None
            if 'weakness' in raw_data :
                # provided, so create the XML structure
                raw_data_weakness = raw_data['weakness']
                weakness_message = ss_comms_xml.WeaknessMessageTypeSub(\
                    cwe=raw_data_weakness.get('cwe', None), #optional
                    file_name=raw_data_weakness.get('file_name', None), #optional
                    function_name=raw_data_weakness.get('function_name', None), #optional
                    line_number=raw_data_weakness.get('line_number', None), #optional
                    additional_information=raw_data_weakness.get('additional_information', None)) #optional
            
            if 'impact' in raw_data :
                # provided, so create the XML structure
                raw_data_impact = raw_data['impact']
                impact_message = ss_comms_xml.TechnicalImpactMessageTypeSub(\
                    effect=raw_data_impact['effect'], #required
                    additional_information=raw_data_impact.get('additional_information', None)) #optional
            
            action_message = ss_comms_xml.ActionMessageTypeSub(\
                behavior=raw_data['behavior'], #required
                weakness=weakness_message, #optional
                impact=impact_message, #optional
                additional_information=raw_data.get('additional_information', None)) #optional
            
        elif content_type == ResolvedContentType.xml :
            # decode with generate DS, validate against schema as parsed
            try :
                action_message = self._xml_parse_string(self.request.body, content_charset)
            except etree.XMLSyntaxError, err_xml_parse :
                self.send_error(status_code=400, 
                    error_message="XML Failure to parse: %s" %(err_xml_parse.msg))
                return
            
            if isinstance(action_message, ss_comms_xml.supermod.ActionMessageType) :
                pass
            else :
                action_message = None
                self.send_error(status_code=400,
                    error_message='Received improper message type for action.')
                return
        else :
            # we should never get here, but catch anyway
            self.send_error(status_code=415, 
                error_message='Content type or character encoding \'{0}\' not implemented.'.format(self.request.headers['content-type']))
            return
        
        # wrap the log message into a ReceivedMessageType element.  
        # this will now include a receive timestamp.
        message = ss_comms_xml.ReceivedMessageTypeSub(received=received_timestamp, 
            action=action_message, hostname=host)
        
        # put it on the queue for the logger to process and continue
        # this does not block
        self.message_queue.put(message)
        
        # acknowledge the success
        self._write_success(201, content_type)
        
        # set response status to created (HTTP 201)
        self.set_status(201)
        return
    
    def put(self) :
         # treat put and post as the same action
         self.post()
    
    def delete(self) :
        # deletes are not supported
        self.send_error(status_code=405, 
            error_message='Action messages may not be deleted via this API.')

    def options(self) :
        # tell the requester that we support POST and PUT
        self.set_header('allow', 'OPTIONS,POST,PUT')
