#!/usr/bin/env python2.7
# -----------------------------Copyright-------------------------------------
# NOTICE
#
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
#
# Copyright (c) 2014. All Rights Reserved.
# -----------------------------Copyright--------------------------------------

import argparse
import time
import signal
import tornado.ioloop
import multiprocessing
import threading
import stonesoup.commapi.utils.utils as ss_comms_utils
import jsonschema

from stonesoup.commapi.handlers import LogHandler
from stonesoup.commapi.handlers import WeaknessHandler
from stonesoup.commapi.handlers import ImpactHandler
from stonesoup.commapi.handlers import ActionHandler
from stonesoup.commapi.handlers import ResultHandler
from stonesoup.commapi.handlers import UnsupportedHandler
from stonesoup.commapi.utils.logger import XmlLogger

class ServerShutdownMonitor(threading.Thread):
    def __init__(self) :
        threading.Thread.__init__(self)
        # make this a daemon so we don't have to wait for it to exit.
        # this will be useful if killed via a signal.
        self.daemon = True
        self.__shutdown_event = threading.Event()

    @property
    def shutdown_event(self) :
        return self.__shutdown_event

    def run(self) :
        # wait for the event to be set
        self.__shutdown_event.wait()
        ioloop = tornado.ioloop.IOLoop.instance()
        # this is designed to be called from a different thread, and
        # using the add_callback is the only safe way to stop tornado.
        # all other methods are not thread safe
        ioloop.add_callback(lambda x: x.stop(), ioloop)


class CommServer():
    """
    Server that handles accepting messages from the Performer and logging them
    to a file.
    """

    def __init__(self, *args, **kwargs):
        """
        Constructor
        """

        self._logger = None
        self._monitor = None
        self._process = None
        self._portnum = kwargs.get('portnum', "8886")
        self._servip = kwargs.get('servip', "127.0.0.1")
        self._logfile = kwargs.pop('logfile')
        self._verbose = kwargs.get("verbose", False)

    def _start(self):
        """
        Multiprocess start function - this function gets called from
        The main start method and is used to execute the comms api server
        """
        self._logger = XmlLogger(self._logfile)
        self._monitor = ServerShutdownMonitor()

        # -------------------------------------------------------------------------
        #  2. pre-load schemas
        # -------------------------------------------------------------------------
        # xml scehmas
        xml_schema = ss_comms_utils.load_xml_schema('communications')

        # json schemas
        log_schema = ss_comms_utils.load_json_schema('log')
        weakness_schema = ss_comms_utils.load_json_schema('weakness')
        impact_schema = ss_comms_utils.load_json_schema('impact')
        action_schema = ss_comms_utils.load_json_schema('action')
        result_schema = ss_comms_utils.load_json_schema('result')

        # create a schema store for jsonschema validator.  this will
        # allow us to resolve type references without publishing them
        # at a URL
        schema_store = { log_schema['id']: log_schema,
                         weakness_schema['id']: weakness_schema,
                         impact_schema['id']: impact_schema,
                         action_schema['id']: action_schema,
                         result_schema['id']: result_schema }

        # the resolver will get types defined in other schemas
        resolver = jsonschema.RefResolver('',
            log_schema,         # this is no longer used according to jsonschema docs
            store=schema_store)

        # -------------------------------------------------------------------------
        #  3. Create the tornado application
        # -------------------------------------------------------------------------
        application = tornado.web.Application([
            (r"/log", LogHandler, dict(message_queue=self._logger.message_queue,
                json_validator=jsonschema.Draft4Validator(log_schema, resolver=resolver),
                xml_schema=xml_schema)),
            (r"/weakness", WeaknessHandler, dict(message_queue=self._logger.message_queue,
                json_validator=jsonschema.Draft4Validator(weakness_schema, resolver=resolver),
                xml_schema=xml_schema)),
            (r"/impact", ImpactHandler, dict(message_queue=self._logger.message_queue,
                json_validator=jsonschema.Draft4Validator(impact_schema, resolver=resolver),
                xml_schema=xml_schema)),
            (r"/action", ActionHandler, dict(message_queue=self._logger.message_queue,
                json_validator=jsonschema.Draft4Validator(action_schema, resolver=resolver),
                xml_schema=xml_schema)),
            (r"/result", ResultHandler, dict(message_queue=self._logger.message_queue,
                json_validator=jsonschema.Draft4Validator(result_schema, resolver=resolver),
                xml_schema=xml_schema,
                shutdown_event=self._monitor.shutdown_event)),
            (r".*", UnsupportedHandler),
        ])

        # ---------------------------------------------------------------------
        #  4. Start everything
        # ---------------------------------------------------------------------
        # start the logger first, because the server
        # will block on the current thread
        self._logger._instance = self._logger
        self._logger.start()

        # start the shutdown event listener
        self._monitor.start()

        def shutdown_handler(signum, frame) :
            if self._verbose:
                print("Received signal : {}".format(signum))


            if self._logger is not None:
                self._logger.message_queue.put(None)

            if self._verbose:
                print("Logger none job added : {}".format(self._logger))
            ioloop = tornado.ioloop.IOLoop.instance()
            # this is designed to be called from a different thread, and
            # using the add_callback is the only safe way to stop tornado.
            # all other methods are not thread safe

            if self._verbose:
                print("Shutting down ioloop")
            ioloop.add_callback_from_signal(lambda x: x.stop(), ioloop)
            if self._logger is not None:
                if self._verbose:
                    print "Joining thread"
                    self._logger.join()
            if self._verbose:
                print("Done")

        # set signal handlers for termination
        signal.signal(signal.SIGINT, shutdown_handler)
        signal.signal(signal.SIGTERM, shutdown_handler)

        # start the message server, this call will block until stopped
        # SS_COMM_PORT
        # socket.error:
        application.listen(port=self._portnum, address=self._servip)
        tornado.ioloop.IOLoop.instance().start()

        # ---------------------------------------------------------------------
        #  5. Shutdown
        # ---------------------------------------------------------------------
        self._logger.join()

    def start(self):
        """
        Start the server if it's not running. Otherwise return.
        """
        self._process = multiprocessing.Process(target=self._start)
        self._process.start()

        # Wait for server to initialize before moving on
        timeout = 10
        deadline = time.time() + timeout
        delay = 1
        while 1:
            try:
                started = tornado.ioloop.IOLoop.instance().initialized()
            except:
                started = False
            if started:
                break
            remaining = deadline - time.time()
            if remaining <= 0:
                break
            delay = min(delay, remaining, 5)
            time.sleep(delay)

    def stop(self, timeout=None):
        """
        Stop the server if it's running. Otherwise return.
        """

        if self._process is None:
            if self._verbose:
                print("Server is empty, exiting.")
            return

        #if the server is not dead, then kill it
        if self._process.is_alive():
            if self._verbose:
                print("Attempting to terminate process, its alive.")
            self._process.terminate()

        if self._verbose:
            print("Waiting for join..")
        self._process.join(timeout)
        if self._verbose:
            print("Process joined for: {}".format(timeout))

    def wait(self, timeout=None):

        self._process.join(timeout)


def main():
        parser = argparse.ArgumentParser(
            description="Stone Soup Job Communications Web Server")
        parser.add_argument(
            "--port", help="Sever listen port, default is 8886",
            dest="portnum", type=int, default = 8886)
        parser.add_argument(
            "--ip", help="Sever bind IP, default is 127.0.0.1",
            dest="servip", type=str,  default="127.0.0.1")
        parser.add_argument(
            "--logfile",
            help="Specified log file, default is <curr_dir>/messages.xml",
            dest="logfile", type=str, default=None)
        args = parser.parse_args()

        server = CommServer(portnum=args.portnum, servip=args.servip,
                            logfile=args.logfile)
        server._start()

if __name__ == '__main__':
        main()